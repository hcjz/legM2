unit HGEGUI;

interface

uses
  Windows, Classes, Graphics, Controls, StrUtils, SysUtils, Grids,
 Clipbrd, imm, HGE, HGECanvas, HGETextures, HGEDControls,
  WIL, HUtil32, HGEBase, DirectXD3D9;
  
const
  AllowedChars = [#32..#254];
  AllowedIntegerChars = [#48..#57];
  AllowedEnglishChars = [#33..#126];
  AllowedStandard = [#48..#57, #65..#90, #97..#122];
  AllowedCDKey = [#48..#57, #65..#90, #95, #97..#122];

  WINLEFT = 60;
  WINTOP = 60;

  DEFFONTNAME = '宋体';
  DEFFONTSIZE = 9;
  DEFFONTSIZE9 = 9;
  DEFFONTSIZE12 = 12;  

type
  pTDTreeNodes = ^TDTreeNodes;
  TDTreeNodes = packed record
    sName: string;
    Item: Pointer;
    ItemList: TList;
    boOpen: Boolean;
    nNameLen: Integer;
    boMaster: Boolean;
  end;
  TButtonStyle = (bsButton, bsRadio, bsCheckBox);
  TClickSound = (csNone, csStone, csGlass, csNorm); //按键音类型
  TDEditClass = (deNone, deInteger, deMonoCase, deChinese, deStandard, deEnglishAndInt, deCDKey); //EDIT类型
  TMouseEntry = (msIn, msOut); //MOUSE输入输出?
  TDControlStyle = (dsNone, dsTop, dsBottom);
  TMouseWheel = (mw_Down, mw_Up); //MOUSE按下放起定义？
  TOnScroll = procedure(Sender: TObject; Increment: Integer) of object;
  TDControl = class;
  TOnDirectPaint = procedure(Sender: TObject; dsurface: TDXDrawCanvas) of object;
  TOnKeyPress = procedure(Sender: TObject; var Key: Char) of object;
  TOnKeyDown = procedure(Sender: TObject; var Key: word; Shift: TShiftState) of object;
  TOnKeyUp = procedure(Sender: TObject; var Key: word; Shift: TShiftState) of object;
  TOnMouseWheel = procedure(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer) of object;
  TOnMouseMove = procedure(Sender: TObject; Shift: TShiftState; X, Y: integer) of object;
  TOnMouseDown = procedure(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: integer) of object;
  TOnMouseUp = procedure(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer) of object;
  TOnClick = procedure(Sender: TObject) of object;
  TOnVisible = procedure(Sender: TObject; boVisible: Boolean) of object;
  TOnClickEx = procedure(Sender: TObject; X, Y: integer) of object;
  TOnInRealArea = procedure(Sender: TObject; X, Y: integer; var IsRealArea: Boolean) of object;
  TOnGridSelect = procedure(Sender: TObject; ACol, ARow: integer; Shift: TShiftState) of object;
  TOnItemIndex = procedure(Sender: TObject; ItemIndex, SubIndex: integer) of object;
  TOnGridPaint = procedure(Sender: TObject; ACol, ARow: integer; Rect: TRect; State: TGridDrawState;
    dsurface: TDXDrawCanvas) of object;
  TOnClickSound = procedure(Sender: TObject; Clicksound: TClickSound) of object;
  TOnMouseEntry = procedure(Sender: TObject; MouseEntry: TMouseEntry) of object;
  TOnCheckItem = procedure(Sender: TObject; ItemIndex: Integer; var ItemName: string) of object;
  TOnDrawEditImage = procedure(Sender: TObject; ImageSurface: TDXTexture; Rect: TRect; ImageIndex: Integer) of object;
  TOnTreeViewSelect = procedure(Sender: TObject; DTreeNodes: pTDTreeNodes) of object;
  TOnTreeClearItem = procedure(Sender: TObject; DTreeNodes: pTDTreeNodes) of object;

  TDImageIndex = class(TPersistent)
  private
    FOnChange: TNotifyEvent;
    FUp: Integer;
    FHot: Integer;
    FDown: Integer;
    FDisabled: Integer;
    procedure SetUp(Value: Integer);
    procedure SetHot(Value: Integer);
    procedure SetDown(Value: Integer);
    procedure SetDisabled(Value: Integer);
  protected
    procedure Changed; //dynamic;
  public
    constructor Create;
    procedure Assign(Source: TPersistent); override;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  published
    property Up: Integer read FUp write SetUp;
    property Hot: Integer read FHot write SetHot;
    property Down: Integer read FDown write SetDown;
    property Disabled: Integer read FDisabled write SetDisabled;
  end;

  TDControl = class(TCustomControl)
  private
    FCaption: string;

    FDParent: TDControl;
    FReadOnly: Boolean;
    FMouseFocus: Boolean;
    FKeyFocus: Boolean;
    FDXChecked: Boolean;
    FOnDirectPaint: TOnDirectPaint; 
    FOnEndDirectPaint: TOnDirectPaint; 
    FOnKeyPress: TOnKeyPress; 
    FOnKeyDown: TOnKeyDown; 
    FOnKeyUp: TOnKeyUp;
    FWheelDControl: TDControl;
    FOnMouseWheel: TOnMouseWheel;
    FOnMouseMove: TOnMouseMove;
    FOnMouseDown: TOnMouseDown; 
    FOnMouseUp: TOnMouseUp; 
    FOnDblClick: TNotifyEvent; 
    FOnClick: TOnClickEx; 
    FOnInRealArea: TOnInRealArea; 
    FOnBackgroundClick: TOnClick; 
    FOnMouseEntry: TOnMouseEntry;
    FMouseEntry: TMouseEntry;
    FOnEnter: TOnClick;
    FOnLeave: TOnClick;
    FOnVisible: TOnVisible;
    FChangeCaption: Boolean;
    FSurface: TDXTexture;
    FAppendData: Pointer;
    FDFColor: TColor;
    FDFMoveColor: TColor;
    FDFEnabledColor: TColor;
    FDFDownColor: TColor;
    FDFBackColor: TColor;
    FEnableFocus: Boolean; //0x1F8
    FFloating: Boolean;
    SpotX, SpotY: integer;
    procedure SetCaption(str: string);
    procedure SetVisible(flag: Boolean);
//    procedure DNameString(str: string);
  protected
    FVisible: Boolean;
    FVisibleX: Boolean;
    FIsHide: Boolean;
    FEnabled: Boolean;
    KeyAdder: Boolean;
    FTabDControl: TDControl;
  public
    Background: Boolean; 
    DControls: TList; 
    DTabControls: TList; 
    
    WLib: TWMImages; 
    FaceIndex: integer; 
    WantReturn: Boolean; 
    AppendTick: LongWord;
    DFileName: string;
    FDNameString: string;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure Loaded; override;
    function SurfaceX(x: integer): integer;
    function SurfaceY(y: integer): integer;
    function LocalX(x: integer): integer;
    function LocalY(y: integer): integer;
    procedure AddChild(dcon: TDControl);
    procedure DelChild(dcon: TDControl);
    procedure ChangeChildOrder(dcon: TDControl);
    function  Focused: Boolean;
    function InRange(x, y: integer): Boolean; reintroduce; dynamic;
    function KeyPress(var Key: Char): Boolean; reintroduce; dynamic;
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean; reintroduce; dynamic;
    function KeyUp(var Key: Word; Shift: TShiftState): Boolean; reintroduce; dynamic;
    function MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean; reintroduce; dynamic;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; reintroduce; dynamic;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; reintroduce; dynamic;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; reintroduce; dynamic;
    function EscClose: Boolean; dynamic;
    function DblClick(X, Y: integer): Boolean; reintroduce; dynamic;
    function CheckTab(): Boolean; dynamic;
    procedure CloseSurface(); dynamic;
    procedure IsVisible(flag: Boolean); dynamic;

    function Click(X, Y: integer): Boolean; reintroduce; dynamic;
    function CanFocusMsg: Boolean;
    procedure Leave(); dynamic;
    procedure Enter(); dynamic;
    procedure SetFocus(); reintroduce; dynamic;
    Function Selected(): Boolean; dynamic;
    procedure SetImgIndex(Lib: TWMImages; index: integer);
    procedure CreateSurface(Lib: TWMImages; boActive: Boolean = True; index: integer = 0); dynamic;
    procedure DirectPaint(dsurface: TDXDrawCanvas); dynamic;
    property MouseEntry: TMouseEntry read FMouseEntry;
    property ChangeCaption: Boolean read FChangeCaption;
    property IsHide: Boolean read FIsHide;
    property Surface: TDXTexture read FSurface;
    property AppendData: Pointer read FAppendData write FAppendData;

  published
    property DFColor: TColor read FDFColor write FDFColor;
    property DFEnabledColor: TColor read FDFEnabledColor write FDFEnabledColor;
    property DFMoveColor: TColor read FDFMoveColor write FDFMoveColor;
    property DFDownColor: TColor read FDFDownColor write FDFDownColor;
    property DFBackColor: TColor read FDFBackColor write FDFBackColor;

    property OnDirectPaint: TOnDirectPaint read FOnDirectPaint write FOnDirectPaint;
    property OnEndDirectPaint: TOnDirectPaint read FOnEndDirectPaint write FOnEndDirectPaint;
    property OnKeyPress: TOnKeyPress read FOnKeyPress write FOnKeyPress;
    property OnKeyDown: TOnKeyDown read FOnKeyDown write FOnKeyDown;


    property OnMouseWheel: TOnMouseWheel read FOnMouseWheel write FOnMouseWheel;
    property OnMouseMove: TOnMouseMove read FOnMouseMove write FOnMouseMove;
    property OnMouseDown: TOnMouseDown read FOnMouseDown write FOnMouseDown;
    property OnMouseUp: TOnMouseUp read FOnMouseUp write FOnMouseUp;
    property OnDblClick: TNotifyEvent read FOnDblClick write FOnDblClick;
    property OnClick: TOnClickEx read FOnClick write FOnClick;
    property OnInRealArea: TOnInRealArea read FOnInRealArea write FOnInRealArea;
    property OnBackgroundClick: TOnClick read FOnBackgroundClick write
      FOnBackgroundClick;
    property OnMouseEntry: TOnMouseEntry read FOnMouseEntry write FOnMouseEntry;
    property OnEnter: TOnClick read FOnEnter write FOnEnter;
    property OnLeave: TOnClick read FOnLeave write FOnLeave;
    property OnVisible: TOnVisible read FOnVisible write FOnVisible;
    property WheelDControl: TDControl read FWheelDControl write FWheelDControl;
    property Caption: string read FCaption write SetCaption;
    property NameString: string read FDNameString write FDNameString;
    property DParent: TDControl read FDParent write FDParent;
    property Visible: Boolean read FVisible write SetVisible;
    property VisibleX: Boolean read FVisibleX write SetVisible;
    property DXFileName: string read DFileName write DFileName;
    property Enabled: Boolean read FEnabled write FEnabled;
    property EndKeyRead: Boolean read KeyAdder write KeyAdder;
    property ReadOnly: Boolean read FReadOnly write FReadOnly default False;
    property MouseFocus: Boolean read FMouseFocus write FMouseFocus;
    property EnableFocus: Boolean read FEnableFocus write FEnableFocus;
    property Floating: Boolean read FFloating write FFloating;
    property DXChecked: Boolean read FDXChecked write FDXChecked;
    property Color;
    property Font;
    property Hint;
    property ShowHint;
    property Align;
  end;  
  TOnPopIndex = procedure(Sender, DControl: TDControl; ItemIndex: integer; UserName: string) of object;

  TDButton = class(TDControl)
  private
    FClickSound: TClickSound;
    FOnClick: TOnClickEx;
    FOnClickSound: TOnClickSound;
  public
    Downed: Boolean;
    Moveed: Boolean;
    constructor Create(AOwner: TComponent); override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
  published
    property ClickCount: TClickSound read FClickSound write FClickSound;
    property OnClick: TOnClickEx read FOnClick write FOnClick;
    property OnClickSound: TOnClickSound read FOnClickSound write FOnClickSound;
  end;

   TDListButton = class (TDControl)
   private
      FColCount, FRowCount: integer;
      FColWidth, FRowHeight: integer;
      FViewTopLine: integer;
      SelectCell: TPoint;
      DownPos: TPoint;
      FOnGridSelect: TOnGridSelect;
      FOnGridMouseMove: TOnGridSelect;
      FOnGridPaint: TOnGridPaint;
      function  GetColRow (x, y: integer; var acol, arow: integer): Boolean;
   public
      CX, CY: integer;
      Col, Row: integer;
      constructor Create (AOwner: TComponent); override;
      function  MouseMove (Shift: TShiftState; X, Y: Integer): Boolean; override;
      function  MouseDown (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
      function  MouseUp (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
      function  Click (X, Y: integer): Boolean; override;
      procedure DirectPaint (dsurface: TDXDrawCanvas); override;
   published
      property ColCount: integer read FColCount write FColCount;
      property RowCount: integer read FRowCount write FRowCount;
      property ColWidth: integer read FColWidth write FColWidth;
      property RowHeight: integer read FRowHeight write FRowHeight;
      property ViewTopLine: integer read FViewTopLine write FViewTopLine;
      property OnGridSelect: TOnGridSelect read FOnGridSelect write FOnGridSelect;
      property OnGridMouseMove: TOnGridSelect read FOnGridMouseMove write FOnGridMouseMove;
      property OnGridPaint: TOnGridPaint read FOnGridPaint write FOnGridPaint;
   end;

   TDMoveButton = class (TDControl)
   private
      FClickSound: TClickSound;
      FOnClick: TOnClickEx;
      FOnClickSound: TOnClickSound;
      SpotX, SpotY: integer;
      TpotX, TpotY: integer;
   public
     Downed: Boolean;
     Moveed: Boolean;
     MoveXbo: Boolean; //是否可左右移动
     MoveYbo: Boolean; //是否可上下移动
     MoveMinX:Integer; //左移动最少位置坐标
     MoveMaxX:Integer; //右移动最大位置坐标
     MoveMinY:Integer; //上移动最少位置坐标
     MoveMaxY:Integer; //下移动最大位置坐标
     MoveOutIDX:Integer; //输出值
     InMaxIDX:Integer;//输入值
     InmfIDX:Integer;//平均值
     MouseDownbo :Boolean;
     constructor Create (AOwner: TComponent); override;
     function  MouseMove (Shift: TShiftState; X, Y: Integer): Boolean; override;
     function  MouseDown (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
     function  MouseUp (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
     procedure OnAddIDXCreateX(intdex: Integer);
   published
     property ClickCount: TClickSound read FClickSound write FClickSound;
     property OnClick: TOnClickEx read FOnClick write FOnClick;
     property OnClickSound: TOnClickSound read FOnClickSound write FOnClickSound;
     property TMoveX: Boolean read MoveXbo write MoveXbo; //是否可左右移动
     property TMoveY: Boolean read MoveYbo write MoveYbo; //是否可上下移动
     property TMoveMinX: Integer read MoveMinX write MoveMinX; //左移动最少位置坐标
     property TMoveMaxX: Integer read MoveMaxX write MoveMaxX; //右移动最大位置坐标
     property TMoveMinY: Integer read MoveMinY write MoveMinY; //上移动最少位置坐标
     property TMoveMaxY: Integer read MoveMaxY write MoveMaxY; //下移动最大位置坐标
     property TInMaxIDX: Integer read InMaxIDX write InMaxIDX; //输入值
   end;

  
  TDGrid = class(TDControl)
  private
    FColCount, FRowCount: integer;
    FColWidth, FRowHeight: integer;
    FColoffset, FRowoffset: Integer;
    FViewTopLine: integer;
    FSelectCell: TPoint;
    DownPos: TPoint;
    FOnGridSelect: TOnGridSelect;
    FOnGridMouseMove: TOnGridSelect;
    FOnGridPaint: TOnGridPaint;
    function GetColRow(x, y: integer; var acol, arow: integer): Boolean;
  public
    CX, CY: integer;
    Col, Row: integer;
    constructor Create(AOwner: TComponent); override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function Click(X, Y: integer): Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
  published
    property ColCount: integer read FColCount write FColCount;
    property RowCount: integer read FRowCount write FRowCount;
    property ColWidth: integer read FColWidth write FColWidth;
    property RowHeight: integer read FRowHeight write FRowHeight;
    property Coloffset: integer read FColoffset write FColoffset;
    property Rowoffset: integer read FRowoffset write FRowoffset;
    property ViewTopLine: integer read FViewTopLine write FViewTopLine;
    property OnGridSelect: TOnGridSelect read FOnGridSelect write FOnGridSelect;
    property OnGridMouseMove: TOnGridSelect read FOnGridMouseMove write FOnGridMouseMove;
    property OnGridPaint: TOnGridPaint read FOnGridPaint write FOnGridPaint;
  end;
  
  TDWindow = class(TDButton)
  private
    FEscClose: Boolean;
    FControlStyle: TDControlStyle;
  protected
    procedure SetVisible(flag: Boolean);
  public
    DialogResult: TModalResult;
    constructor Create(AOwner: TComponent); override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    function EscClose: Boolean; override;
    procedure Show;
    function ShowModal: integer;
    procedure TopShow();
  published
    property Visible: Boolean read FVisible write SetVisible;
    property EscExit: Boolean read FEscClose write FEscClose;
    property ControlStyle: TDControlStyle read FControlStyle write FControlStyle;
    
  end;

  TDlgInfo = packed record
    Rect: TRect;
    WMImages: TWMImages;
    Index: Integer;
  end;

  TDModalWindow = class(TDWindow)
  public
    YesResult: TModalResult;
    NoResult: TModalResult;
    MsgList: TStringList;
    DlgInfo: array[0..7] of TDlgInfo;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ModalShow: integer;
    function ModalClose: integer;
  end;

  TDCheckBox = class(TDControl)
  private
    FChecked: Boolean;
    FFontSpace: Integer;
    FOnClick: TOnClickEx;
    FWidth: Integer;
    FHeight: Integer;
    FOffsetLeft: Integer;
    FOffsetTop: Integer;
    FOnCheckedChange: TOnClick;
  public
    Moveed: Boolean; //20080624
    Chackop:Boolean;
    constructor Create(AOwner: TComponent); override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    function InRange(x, y: integer): Boolean; override;
  published
    property Checked: Boolean read FChecked write FChecked;
    property FontSpace: Integer read FFontSpace write FFontSpace;
    property OnClick: TOnClickEx read FOnClick write FOnClick;
    property OnChange: TOnClick read FOnCheckedChange write FOnCheckedChange;
    property OffsetLeft: Integer read FOffsetLeft write FOffsetLeft;
    property OffsetTop: Integer read FOffsetTop write FOffsetTop;
  end;

  TDUpDown = class(TDButton)
  private
    FUpButton: TDButton;
    FDownButton: TDButton;
    FMoveButton: TDButton;
    FPosition: Integer;
    FMaxPosition: Integer;
    FOnPositionChange: TOnClick;
    FTop: Integer;
    FAddTop: Integer;
    FMaxLength: Integer;
    FOffset: Integer;                    
    FBoMoveShow: Boolean;
    FboMoveFlicker: Boolean;
    FboNormal: Boolean;
    StopY: Integer;
    FStopY: Integer;
    FClickTime: LongWord;
    FMovePosition: Integer;
    procedure SetButton(Button: TDButton);
    procedure SetPosition(value: Integer);
    procedure SetMaxPosition(const Value: Integer);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    procedure ButtonMouseMove(Sender: TObject; Shift: TShiftState; X, Y: integer);
    procedure ButtonMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure ButtonMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    property UpButton: TDButton read FUpButton;
    property DownButton: TDButton read FDownButton;
    property MoveButton: TDButton read FMoveButton;
  published
    property Position: Integer read FPosition write SetPosition;
    property Offset: Integer read FOffset write FOffset;
    property Normal: Boolean read FboNormal write FboNormal;
    property MovePosition: Integer read FMovePosition write FMovePosition;
    property MoveShow: Boolean read FBoMoveShow write FBoMoveShow;
    property MaxPosition: Integer read FMaxPosition write SetMaxPosition;
    property MoveFlicker: Boolean read FboMoveFlicker write FboMoveFlicker;
    property OnPositionChange: TOnClick read FOnPositionChange write FOnPositionChange;
  end;

  TDHooKKey = class(TDControl)
  private
    FShiftState: TShiftState;
    FKey: Word;
    FText: string;
    FFrameColor: TColor;
    FOnChange: TOnClick;
    procedure SetShiftState(Value: TShiftState);
    procedure SetKey(Value: Word);
  public
    constructor Create(AOwner: TComponent); override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean; override;
    procedure RefHookKeyStr();
    property Text: string read FText;
  published
    property ShiftState: TShiftState read FShiftState write SetShiftState;
    property Key: Word read FKey write SetKey;
    property FrameColor: TColor read FFrameColor write FFrameColor;
    property OnChange: TOnClick read FOnChange write FOnChange;
  end;

  TDCustomEdit = class(TDControl)
  private
    FEditClass: TDEditClass;
    FPasswordChar: Char;
  public
    constructor Create(AOwner: TComponent); override;

    procedure Enter(); override;
    procedure Leave(); override;
    procedure IsVisible(flag: Boolean); override;
  published
    property EditClass: TDEditClass read FEditClass write FEditClass;
    property PasswordChar: Char read FPasswordChar write FPasswordChar default #0;
  end;

  TCursor = (deLeft, deRight);

  TDMemo = class(TDCustomEdit)
  private
    FLines: TStrings;
    FOnChange: TOnClick;
    FFrameColor: TColor;
    FCaretShowTime: LongWord;
    FCaretShow: Boolean;
    FTopIndex: Integer;
    FCaretX: Integer;
    FCaretY: Integer;
    FSCaretX: Integer;
    FSCaretY: Integer;
    FUpDown: TDUpDown;
    FMoveTick: LongWord;
    FInputStr: string;
    bDoubleByte: Boolean;
    KeyByteCount: Integer;
    FTransparent: Boolean;
    FMaxLength: integer;
    
    procedure DownCaret(X, Y: Integer);
    procedure MoveCaret(X, Y: Integer);
    procedure KeyCaret(Key: Word);
    procedure SetUpDown(const Value: TDUpDown);
    procedure SetCaret(boBottom: Boolean);
    function ClearKey(): Boolean;
    function GetKey(): string;
    procedure SetCaretY(const Value: Integer);
  public
    Downed: Boolean;
    KeyDowned: Boolean;

    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    procedure IsVisible(flag: Boolean); override;
    function KeyPress(var Key: Char): Boolean; override;
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean; override;
    function KeyUp(var Key: Word; Shift: TShiftState): Boolean; override;

    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;

    procedure Enter(); override;
    procedure Leave(); override;
    procedure SetFocus(); override;
    function GetText(): string;
    Function Selected(): Boolean; override;
    procedure PositionChange(Sender: TObject);
    procedure TextChange();

    property Lines: TStrings read FLines;
    property ItemIndex: Integer read FCaretY write SetCaretY;

    procedure RefListWidth(ItemIndex: Integer; nCaret: Integer);
  published
    property OnChange: TOnClick read FOnChange write FOnChange;
    property FrameColor: TColor read FFrameColor write FFrameColor;

    property UpDown: TDUpDown read FUpDown write SetUpDown;
    property boTransparent: Boolean read FTransparent write FTransparent;
    property MaxLength: Integer read FMaxLength write FMaxLength default 0;
  end;

  TDMemoStringList = class(TStringList)
    DMemo: TDMemo;
  private
    procedure Put(Index: Integer; const Value: string); reintroduce;
    function SelfGet(Index: Integer): string;
  published
  public
    function Add(const S: string): Integer; override;
    function AddObject(const S: string; AObject: TObject): Integer; override;
    procedure InsertObject(Index: Integer; const S: string;
      AObject: TObject); override;
    function Get(Index: Integer): string; override;

    function GetText: PChar; override;
    procedure LoadFromFile(const FileName: string); override;
    procedure SaveToFile(const FileName: string); override;

    property Str[Index: Integer]: string read SelfGet write Put; default;
    procedure Assign(Source: TPersistent); override;
    procedure Clear; override;
  end;


  TDEdit = class(TDCustomEdit)
  private
    //FReadOnly: Boolean;
    FEditString: WideString;
    FFrameColor: TColor;
    FFCaretShowColor: TColor;
    FCaretShowTime: LongWord;
    FCaretShow: Boolean;
    FMaxLength: Integer;
    FInputStr: string;
    bDoubleByte: Boolean;
    KeyByteCount: Integer;
    FCursor: TCursor;
    FStartX: Integer;
    FStopX: Integer;
    FCaretStart: Integer; 
    FCaretStop: Integer; 
    FCaretPos: Integer; 
    FOnChange: TOnClick;
    FIndent: Integer;
    FCloseSpace: Boolean;
    FTransparent: Boolean;
    procedure SetCursorPos(cCursor: TCursor);
    procedure SetCursorPosEx(nLen: Integer);
    procedure SetText(Value: string);
    function GetText(): string;
    procedure MoveCaret(X, Y: Integer);
    function ClearKey(): Boolean;
    function GetPasswordstr(str: string): string;
    function GetCopy(): string;
    function GetValue: Integer;
    procedure SetValue(const Value: Integer);
  public
    Downed: Boolean;
    KeyDowned: Boolean;
    Moveed: Boolean;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function KeyPress(var Key: Char): Boolean; override;
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean; override;
    function KeyUp(var Key: Word; Shift: TShiftState): Boolean; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    procedure Enter(); override;
    procedure Leave(); override;
    procedure SetFocus(); override;
    Function Selected(): Boolean; override;
    procedure TextChange();

    property Value: Integer read GetValue write SetValue;
  published
    property OnChange: TOnClick read FOnChange write FOnChange;
    property Text: string read GetText write SetText;
    property FrameColor: TColor read FFrameColor write FFrameColor;
    property FTimeShowColor: TColor read FFCaretShowColor write FFCaretShowColor;
    property MaxLength: Integer read FMaxLength write FMaxLength default 0;
    property CloseSpace: Boolean read FCloseSpace write FCloseSpace default False;
    property boTransparent: Boolean read FTransparent write FTransparent;

  end;

  TDComboBox = class(TDEdit)
  private
    FUpDown: TDUpDown;
    FItem: TStrings;
    FShowCount: Integer;
    FListHeight: Integer;
    FShowHeight: Integer;
    FListIndex: Integer;
    FX: Integer;
    FY: Integer;
    FDWidth: Integer;
    FItemIndex: Integer;
    FImageWidth: Integer;
    FOnChange: TOnClick;
    procedure SetUpDownButton(Button: TDUpDown);
    procedure SetShowCount(Value: Integer);
    procedure SetShowHeight(Value: Integer);
    procedure SetItem(const Value: TStrings);
    function GetItemIndex: Integer;
    procedure SetItemIndex(const Value: Integer);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DirectPaint(dsurface: TDXDrawCanvas); override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer):
      Boolean; override;
    function InRange(x, y: integer): Boolean; override;
    property UpDown: TDUpDown read FUpDown;

    property ImageWidth: Integer read FImageWidth write FImageWidth;
  published
    property ShowCount: Integer read FShowCount write SetShowCount;
    property ShowHeight: Integer read FShowHeight write SetShowHeight;

    property Item: TStrings read FItem write SetItem;
    property ItemIndex: Integer read GetItemIndex write SetItemIndex;
    property OnChange: TOnClick read FOnChange write FOnChange;
  end;


  TDWinManager = class(TComponent)
  private
  public
    DWinList: TList;
    newidex:Integer;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddDControl(dcon: TDControl; visible: Boolean);
    procedure DelDControl(dcon: TDControl);
    procedure CloseSurface();
    procedure CloseModalShow();
    procedure ClearAll;
    function KeyPress(var Key: Char): Boolean;
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean;
    function KeyUp(var Key: Word; Shift: TShiftState): Boolean;
    function MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
    function DblClick(X, Y: integer): Boolean;
    function Click(X, Y: integer): Boolean;
    function EscClose(): Boolean;
    procedure DirectPaint(dsurface: TDXDrawCanvas);
  end;


 TDScrollBar = class(TDControl)
  private
    FItemHeight: Integer;
    FItemIndex: Integer;
    FMaxValue, FPosition: Integer;
    FPrevImageIndex: TDImageIndex;
    FNextImageIndex: TDImageIndex;
    FBarImageIndex: TDImageIndex;
    FPrevImageSize: Integer;
    FNextImageSize: Integer;
    FBarImageSize: Integer;
    FPrevMouseDown: Boolean;
    FNextMouseDown: Boolean;
    FBarMouseDown: Boolean;
    FPrevMouseMove: Boolean;
    FNextMouseMove: Boolean;
    FBarMouseMove: Boolean;
    FBarTop: Integer;
    FRemoveSize: Integer;
    FScrollSize: Integer;
    FOnScroll: TOnScroll;
    procedure SetItemIndex(Value: Integer);
    procedure SetItemHeight(Value: Integer);
    procedure SetMaxValue(const Value: Integer);
    procedure SetPosition(const Value: Integer);
    procedure SetRemoveSize(const Value: Integer);
    procedure SetScrollSize(const Value: Integer);
    function InPrevRange(X, Y: Integer): Boolean;
    function InNextRange(X, Y: Integer): Boolean;
    function InBarRange(X, Y: Integer): Boolean;
    procedure PrevImageIndexChange(Sender: TObject);
    procedure NextImageIndexChange(Sender: TObject);
    procedure BarImageIndexChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DirectPaint (dsurface: TDXDrawCanvas); override;
    procedure DoResize(var NewRect: TRect);
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    procedure Next;
    procedure Previous;
    procedure First;
    procedure Last;
  published
    property ItemHeight: Integer read FItemHeight write SetItemHeight;
    property ItemIndex: Integer read FItemIndex write SetItemIndex;
    property ScrollSize: Integer read FScrollSize write SetScrollSize;
    property PrevImageIndex: TDImageIndex read FPrevImageIndex write FPrevImageIndex;
    property NextImageIndex: TDImageIndex read FNextImageIndex write FNextImageIndex;
    property BarImageIndex: TDImageIndex read FBarImageIndex write FBarImageIndex;
    property MaxValue: Integer read FMaxValue write SetMaxValue;
    property Position: Integer read FPosition write SetPosition;
    property RemoveSize: Integer read FRemoveSize write SetRemoveSize;
    property OnScroll: TOnScroll read FOnScroll write FOnScroll;
  end;

  TViewItem = record
    Caption: string;
    Data: Pointer;
    Style: TButtonStyle;
    Checked: Boolean;
    Color: TDCaptionColor;
    ImageIndex: TDImageIndex;
    Down, Move: Boolean;
    Transparent: Boolean;
    WLib: TWMImages;
    TimeTick: LongWord;
  end;
  pTViewItem = ^TViewItem;
  TDListItem = class;
  TOnListItem = procedure(Sender: TObject; ARow, ACol: Integer; ListItem: TDListItem; ViewItem: pTViewItem) of object;

  TDListItem = class(TStringList)
  private
    FItemList: array of TViewItem;
    function GetItem(Index: Integer): pTViewItem;
  public
    constructor Create;
    destructor Destroy; override;
    function AddObject(const S: string; AObject: TObject): Integer; override;
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure InsertObject(Index: Integer; const S: string;
      AObject: TObject); override;
    function AddItem(const S: string; AObject: TObject): pTViewItem;
    property Items[Index: Integer]: pTViewItem read GetItem;
  end;

  TDListView = class(TDControl)
  private
    FLines: TList;
    ColWidths: array of Integer;
    FColCount: Integer;
    FOnListItemClick: TOnListItem;
    FHScrollBar: TDScrollBar;            //0x34
    FOnScroll: TNotifyEvent;
    function GetCount: Integer;
    function GetViewItem(Index: Integer): TDListItem;
    function GetColWidth(Index: Integer): Integer;
    procedure SetColWidth(Index: Integer; Value: Integer);
    procedure SetColCount(Value: Integer);
    procedure FillItemMouse;
    procedure SetHScrollBar(Value: TDScrollBar);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function  Click (X, Y: integer): Boolean; override;
    procedure DirectPaint (dsurface: TDXDrawCanvas); override;
    procedure DoScroll(Value: Integer); virtual;
    function Add: TDListItem;
    procedure Clear;
    property Count: Integer read GetCount;
    property Items[Index: Integer]: TDListItem read GetViewItem;
    property ColCount: Integer read FColCount write SetColCount;
    property ColWidth[Index: Integer]: Integer read GetColWidth write SetColWidth;
  published
    property HScrollBar: TDScrollBar read FHScrollBar write SetHScrollBar;
    property OnListItemClick: TOnListItem read FOnListItemClick write FOnListItemClick;
  end;
 TDChatMemoLines = class(TStringList)
  private
    FItemList: array of TViewItem;
    FItemHeightList: array of Integer;
    function GetItem(Index: Integer): pTViewItem;
    function GetItemHeight(Index: Integer): Integer;
    procedure SetItemHeight(Index: Integer; Value: Integer);
  public
    constructor Create;
    destructor Destroy; override;
    function AddObject(const S: string; AObject: TObject): Integer; override;
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure InsertObject(Index: Integer; const S: string;
      AObject: TObject); override;
    function AddItem(const S: string; AObject: TObject): pTViewItem;
    property Items[Index: Integer]: pTViewItem read GetItem;
    property ItemHeights[Index: Integer]: Integer read GetItemHeight write SetItemHeight;
  published

  end;

  TDChatMemo = class(TDControl) //聊天框专用
  private
    Downed: Boolean;
    FShowScroll: Boolean;
    FScrollSize: Integer;
    FItemHeight: Integer;
    FItemIndex: Integer;
    FOnChange: TNotifyEvent;
    FLines: TStrings;
    FTopLines: TStrings;
    FAutoScroll: Boolean;
    FTopIndex: Integer;
    FPosition: Integer;
    FFontBackTransparent: Boolean;
    FOffSetX, FOffSetY: Integer;
    FDrawLineCount: Integer;
    FBarTop: Integer;
    FPrevMouseDown: Boolean;
    FNextMouseDown: Boolean;
    FBarMouseDown: Boolean;
    FScrollMouseDown: Boolean;
    FPrevMouseMove: Boolean;
    FNextMouseMove: Boolean;
    FBarMouseMove: Boolean;

    FScrollImageIndex: TDImageIndex;
    FPrevImageIndex: TDImageIndex;
    FNextImageIndex: TDImageIndex;
    FBarImageIndex: TDImageIndex;
    FPrevImageSize: Integer;
    FNextImageSize: Integer;
    FBarImageSize: Integer;
    FVisibleItemCount: Integer;
    FExpandSize: Integer;
    procedure ScrollImageIndexChange(Sender: TObject);
    procedure PrevImageIndexChange(Sender: TObject);
    procedure NextImageIndexChange(Sender: TObject);
    procedure BarImageIndexChange(Sender: TObject);
    procedure SetExpandSize(Value: Integer);
    procedure SetLines(Value: TStrings);
    procedure SetTopLines(Value: TStrings);
    procedure SetScrollSize(Value: Integer);
    procedure SetItemIndex(Value: Integer);
    procedure SetItemHeight(Value: Integer);
    procedure SetPosition(Value: Integer);
    function GetVisibleHeight: Integer;
    procedure SetVisibleItemCount(Value: Integer);
    function InPrevRange(X, Y: Integer): Boolean;
    function InNextRange(X, Y: Integer): Boolean;
    function InBarRange(X, Y: Integer): Boolean;
  protected
    procedure DoScroll(Value: Integer);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function MaxValue: Integer;
    procedure Next;
    procedure Previous;
    procedure First;
    procedure Last;
    procedure DirectPaint (dsurface: TDXDrawCanvas); override;
    function  MouseDown (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean; override;
    function MouseMove(Shift: TShiftState; X, Y: Integer): Boolean; override;
    procedure LoadFromFile(const FileName: string);
    procedure Add(const S: string; FC, BC: TColor);
    procedure Insert(Index: Integer; const S: string; FC, BC: TColor);
    procedure Delete(Index: Integer);
    procedure AddTop(const S: string; FC, BC: TColor; TimeOut: Integer);
    procedure InsertTop(Index: Integer; const S: string; FC, BC: TColor; TimeOut: Integer);
    procedure DeleteTop(Index: Integer);
    procedure DoResize();
    function KeyDown(var Key: Word; Shift: TShiftState): Boolean; override;
    procedure Clear;
    property TopIndex: Integer read FTopIndex write FTopIndex;
    property FontBackTransparent: Boolean read FFontBackTransparent write FFontBackTransparent;
    property VisibleHeight: Integer read GetVisibleHeight;
  published
    property Position: Integer read FPosition write SetPosition;
    property OffSetX: Integer read FOffSetX write FOffSetX;
    property OffSetY: Integer read FOffSetY write FOffSetY;
    property ScrollImageIndex: TDImageIndex read FScrollImageIndex write FScrollImageIndex;
    property PrevImageIndex: TDImageIndex read FPrevImageIndex write FPrevImageIndex;
    property NextImageIndex: TDImageIndex read FNextImageIndex write FNextImageIndex;
    property BarImageIndex: TDImageIndex read FBarImageIndex write FBarImageIndex;
    property ShowScroll: Boolean read FShowScroll write FShowScroll;
    property ItemHeight: Integer read FItemHeight write SetItemHeight;
    property ItemIndex: Integer read FItemIndex write SetItemIndex;
    property ScrollSize: Integer read FScrollSize write SetScrollSize;
    property Lines: TStrings read FLines write SetTopLines;
    property TopLines: TStrings read FTopLines write SetLines;
    property AutoScroll: Boolean read FAutoScroll write FAutoScroll;
    property DrawLineCount: Integer read FDrawLineCount write FDrawLineCount; //显示列表行数
    property VisibleItemCount: Integer read FVisibleItemCount write SetVisibleItemCount;
    property ExpandSize: Integer read FExpandSize write SetExpandSize;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;
procedure SetDFocus(dcon: TDControl);
procedure ReleaseDFocus;
procedure SetDCapture(dcon: TDControl);
procedure ReleaseDCapture;
procedure SetDKocus(dcon: TDControl);
procedure ReleaseDKocus;
procedure BDXTextOut(surface: TDXDrawCanvas; x, y, fcolor, bcolor: Integer; str:string; WDiv2:Integer=0; HDiv2:Integer=0);

procedure Register;

var
  MouseCaptureControl: TDControl;
  FocusedControl: TDControl;
  KeyControl: TDControl;
  MainWinHandle: integer;
  FrmMainWinHandle: Integer;
  FrmShowIME: Boolean = False;
  FrmIMEX: Integer = 0;
  FrmIMEY: Integer = 0;
  HklKeyboardLayout: LongWord = 0;
  ModalDWindowList: TList;
  ModalDWindow: TDControl;
  TopDWindow: TDControl = nil;
  //PopUpDWindow: TDControl = nil;
  MouseEntryControl: TDControl = nil;
  KeyDownControl: TDControl = nil;
  GUIFScreenWidth: Integer = 800;
  GUIFScreenHeight: Integer = 600;
  TranFrame: Boolean = False;  //2017.6.20
  DXFloating: Boolean = False; //2017.6.20
  //FVisibleX: Boolean;
implementation

var
  ChrBuff: PChar;

procedure Register;
begin
  RegisterComponents('MirGame', [TDWinManager, TDControl, TDButton,TDScrollBar,
   TDListButton, TDMoveButton, TDGrid, TDWindow, TDCheckBox, TDUpDown,TDChatMemo,
    TDListView,TDHooKKey, TDEdit,  TDComboBox,  TDMemo]);
end;

function FiltrateStandardChar(Char1, Char2: Byte): Boolean;
begin
  Result := False;
  case Char1 of
    161: Result := (Char2 in [162..254]);
    162: Result := (Char2 in [161..170, 177..226, 229..238, 241..250{252}]);
    163: Result := (Char2 in [161..254]);
    164: Result := (Char2 in [161..243]);
    165: Result := (Char2 in [161..246]);
    166: Result := (Char2 in [161..184, 193..216, 224..235, 238..242, 244, 245]);
    167: Result := (Char2 in [161..193, 209..241]);
    168: Result := (Char2 in [{64..126, }128..149, 161..187, {189, 190,} 192, 197..233]);
    169: Result := (Char2 in [{64..90, 92, 96..126, }128..136, 150, 164..239]);
    176..214, 216..247: Result := (Char2 in [161..254]);
    215: Result := (Char2 in [161..249]);
  end;
end;

function FiltrateChar(Char1, Char2: Byte): Boolean;
begin
  Result := False;
  case Char1 of
    161: Result := (Char2 in [161..254]);
    162: Result := (Char2 in [161..170, 177..226, 229..238, 241..250{252}]);
    163: Result := (Char2 in [161..254]);
    164: Result := (Char2 in [161..243]);
    165: Result := (Char2 in [161..246]);
    166: Result := (Char2 in [161..184, 193..216, 224..235, 238..242, 244, 245]);
    167: Result := (Char2 in [161..193, 209..241]);
    168: Result := (Char2 in [64..126, 128..149, 161..187, {189, 190,} 192, 197..233]);
    169: Result := (Char2 in [64..90, 92, 96..126, 128..136, 150, 164..239]);
    176..214, 216..247: Result := (Char2 in [161..254]);
    215: Result := (Char2 in [161..249]);
  end;
end;

function GetValidStr3(Str: string; var Dest: string; const Divider: array of
  Char): string;
const
  BUF_SIZE = $7FFF; 
var
  Buf: array[0..BUF_SIZE] of Char;
  BufCount, Count, SrcLen, i, ArrCount: LongInt;
  Ch: Char;
label
  CATCH_DIV;
begin
  Ch := #0; 
  try
    SrcLen := Length(Str);
    BufCount := 0;
    Count := 1;

    if SrcLen >= BUF_SIZE - 1 then begin
      Result := '';
      Dest := '';
      Exit;
    end;

    if Str = '' then begin
      Dest := '';
      Result := Str;
      Exit;
    end;
    ArrCount := SizeOf(Divider) div SizeOf(Char);

    while True do begin
      if Count <= SrcLen then begin
        Ch := Str[Count];
        for i := 0 to ArrCount - 1 do
          if Ch = Divider[i] then
            goto CATCH_DIV;
      end;
      if (Count > SrcLen) then begin
        CATCH_DIV:
        if (BufCount > 0) then begin
          if BufCount < BUF_SIZE - 1 then begin
            Buf[BufCount] := #0;
            Dest := string(Buf);
            Result := Copy(Str, Count + 1, SrcLen - Count);
          end;
          break;
        end
        else begin
          if (Count > SrcLen) then begin
            Dest := '';
            Result := Copy(Str, Count + 2, SrcLen - 1);
            break;
          end;
        end;
      end
      else begin
        if BufCount < BUF_SIZE - 1 then begin
          Buf[BufCount] := Ch;
          Inc(BufCount);
        end; 
        
      end;
      Inc(Count);
    end;
  except
    Dest := '';
    Result := '';
  end;
end;


procedure SetDKocus(dcon: TDControl);
begin
  if KeyControl <> dcon then begin
    if (KeyControl <> nil) then
      KeyControl.Leave;
    dcon.Enter;
  end;
  KeyControl := dcon;
end;

procedure ReleaseDKocus;
begin
  if (KeyControl <> nil) then begin
    KeyControl.Leave;
  end;
  KeyControl := nil;
end;



procedure SetDFocus(dcon: TDControl);
begin
  FocusedControl := dcon;
  if dcon.FKeyFocus then
    SetDKocus(dcon);
end;

procedure ReleaseDFocus;
begin
  FocusedControl := nil;
end;

procedure SetDCapture(dcon: TDControl);
begin
  SetCapture(MainWinHandle);
  MouseCaptureControl := dcon;
end;

procedure ReleaseDCapture;
begin
  ReleaseCapture;
  MouseCaptureControl := nil;
end;
 procedure BDXTextOut(surface: TDXDrawCanvas; x, y, fcolor, bcolor: Integer; str:string; WDiv2:Integer; HDiv2:Integer);
begin
  if g_DXCanvas <> nil  then begin
    if (str <> '') then begin
     if WDiv2 > 0 then X := X - g_DXCanvas.TextWidth(str) div 2;
     if HDiv2 > 0 then Y := Y - g_DXCanvas.TextHeight(str) div 2;
     g_DXCanvas.TextOut(X, Y, str, fcolor);
    end;
  end;
end;

{ TDImageIndex }
constructor TDImageIndex.Create;
begin
  inherited;
  FUp := -1;
  FDown := -1;
  FHot := -1;
  FDisabled := -1;
end;

procedure TDImageIndex.Assign(Source: TPersistent);
begin
  inherited;
  if Source is TDImageIndex then begin
    FUp := TDImageIndex(Source).Up;
    FDown := TDImageIndex(Source).Down;
    FHot := TDImageIndex(Source).Hot;
    FDisabled := TDImageIndex(Source).Disabled;
    Changed;
  end;
end;

procedure TDImageIndex.Changed;
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TDImageIndex.SetDisabled(Value: Integer);
begin
  if FDisabled <> Value then begin
    FDisabled := Value;
    Changed;
  end;
end;

procedure TDImageIndex.SetDown(Value: Integer);
begin
  if FDown <> Value then begin
    FDown := Value;
    Changed;
  end;
end;

procedure TDImageIndex.SetHot(Value: Integer);
begin
  if FHot <> Value then begin
    FHot := Value;
    Changed;
  end;
end;

procedure TDImageIndex.SetUp(Value: Integer);
begin
  if FUp <> Value then begin
    FUp := Value;
    Changed;
  end;
end;

constructor TDControl.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  DParent := nil;
  inherited Visible := FALSE;
  FMouseFocus := True;
  FOnVisible := nil;
  FEnabled := True;
  FEnableFocus := FALSE;
  FFloating := FALSE;
  FDXChecked := False;
  //FSurface := nil;
  FAppendData := nil;
  AppendTick := GetTickCount;
  
  FOnMouseWheel := nil;
  FKeyFocus := False;
  Background := FALSE;
  FReadOnly := False;
  FOnDirectPaint := nil;
  FOnEndDirectPaint := nil;
  FOnKeyPress := nil;
  FOnKeyDown := nil;
  FOnMouseMove := nil;
  FOnMouseDown := nil;
  FOnMouseUp := nil;
  FOnInRealArea := nil;
  DControls := TList.Create;
  DTabControls := TList.Create;
  FDParent := nil;
  FWheelDControl := nil;

  Width := 80;
  Height := 24;
  FCaption := '';
  FDNameString := '';
  FVisible := TRUE;
  FIsHide := True;

  KeyAdder := False;

  WLib := nil;
  FaceIndex := 0;

  FMouseEntry := msOut;
  FOnEnter := nil;
  FOnLeave := nil;

  FTabDControl := nil;

  FDFColor := $C5D2BD;
  FDFMoveColor := $C5D2BD;
  FDFEnabledColor := $C5D2BD;
  FDFDownColor := clWhite;
  FDFBackColor := $8;
end;

procedure TDControl.CreateSurface(Lib: TWMImages; boActive: Boolean; index: integer);
var
  d: TDXTexture;
begin
  if FSurface <> nil then
    FSurface.Free;
  FSurface := nil;
  if Lib <> nil then begin
    d := Lib.Images[index];
    if d <> nil then begin
      FSurface := TDXImageTexture.Create(g_DXCanvas);
      FSurface.Size := d.Size;
      FSurface.PatternSize := d.Size;
      FSurface.Format := d.Format;
      FSurface.Active := boActive;
    end;
  end else begin
    FSurface := TDXImageTexture.Create(g_DXCanvas);
    FSurface.Size := Point(Width, Height);
    FSurface.PatternSize := Point(Width, Height);
    FSurface.Format := D3DFMT_A4R4G4B4;
    FSurface.Active := boActive;
  end;
end;

destructor TDControl.Destroy;
begin
  DControls.Free;
  DTabControls.Free;
  if FSurface <> nil then
    FSurface.Free;
  FSurface := nil;
  inherited Destroy;
end;

function TDControl.Selected: Boolean;
begin
  Result := False;
end;

procedure TDControl.SetCaption(str: string);
begin
  FCaption := str;
  FChangeCaption := True;
  if csDesigning in ComponentState then begin
    Refresh;
  end;
end;



procedure TDControl.SetFocus;
begin
  SetDFocus(Self);
end;


procedure TDControl.Paint;
begin
  if csDesigning in ComponentState then begin
    if self is TDWindow then begin
      with Canvas do begin
        Pen.Color := clBlack;
        MoveTo(0, 0);
        LineTo(Width - 1, 0);
        LineTo(Width - 1, Height - 1);
        LineTo(0, Height - 1);
        LineTo(0, 0);
        LineTo(Width - 1, Height - 1);
        MoveTo(Width - 1, 0);
        LineTo(0, Height - 1);
        TextOut((Width - TextWidth(Caption)) div 2, (Height -
          TextHeight(Caption)) div 2, Caption);
      end;
    end
    else begin
      with Canvas do begin
        Pen.Color := clBlack;
        MoveTo(0, 0);
        LineTo(Width - 1, 0);
        LineTo(Width - 1, Height - 1);
        LineTo(0, Height - 1);
        LineTo(0, 0);
        SetBkMode(Handle, TRANSPARENT);
        Font.Color := self.Font.Color;
        TextOut((Width - TextWidth(Caption)) div 2, (Height -
          TextHeight(Caption)) div 2, Caption);
      end;
    end;
  end;
end;

procedure TDControl.Leave();
begin
  if Assigned(FOnLeave) then
    FOnLeave(Self);
end;

procedure TDControl.Loaded;
var
  i: integer;
  dcon: TDControl;
begin
  if not (csDesigning in ComponentState) then begin
    if Parent <> nil then
      for i := 0 to TControl(Parent).ComponentCount - 1 do begin
        if TControl(Parent).Components[i] is TDControl then begin
          dcon := TDControl(TControl(Parent).Components[i]);
          if dcon.DParent = self then begin
            AddChild(dcon);
          end;
        end;
      end;
  end;
end;



function TDControl.SurfaceX(x: integer): integer;
var
  d: TDControl;
begin
  d := self;
  while TRUE do begin
    if d.DParent = nil then
      break;
    x := x + d.DParent.Left;
    d := d.DParent;
  end;
  Result := x;
end;

function TDControl.SurfaceY(y: integer): integer;
var
  d: TDControl;
begin
  d := self;
  while TRUE do begin
    if d.DParent = nil then
      break;
    y := y + d.DParent.Top;
    d := d.DParent;
  end;
  Result := y;
end;



function TDControl.LocalX(x: integer): integer;
var
  d: TDControl;
begin
  d := self;
  while TRUE do begin
    if d.DParent = nil then
      break;
    x := x - d.DParent.Left;
    d := d.DParent;
  end;
  Result := x;
end;

function TDControl.LocalY(y: integer): integer;
var
  d: TDControl;
begin
  d := self;
  while TRUE do begin
    if d.DParent = nil then
      break;
    y := y - d.DParent.Top;
    d := d.DParent;
  end;
  Result := y;
end;

procedure TDControl.DelChild(dcon: TDControl);
var
  I: Integer;
begin
  for I := 0 to DControls.Count - 1 do begin
    if DControls[I] = dcon then begin
      DControls.Delete(I);
      Break;
    end;
  end;
  if dcon is TDEdit then begin
    for I := 0 to DTabControls.Count - 1 do begin
      if DTabControls[I] = dcon then begin
        DTabControls.Delete(I);
        Break;
      end;
    end;
  end;
end;

procedure TDControl.AddChild(dcon: TDControl);
begin
  DControls.Add(Pointer(dcon));
  if dcon is TDEdit then begin
    DTabControls.Add(Pointer(dcon));
  end;
end;

procedure TDControl.ChangeChildOrder(dcon: TDControl);
var
  i: integer;
  DWindow: TDWindow;
begin
  if not (dcon is TDWindow) then
    exit;
  DWindow := TDWindow(dcon);
  if DWindow.FControlStyle = dsBottom then exit;
  for i := 0 to DControls.Count - 1 do begin
    if dcon = DControls[i] then begin
      DControls.Delete(i);
      break;
    end;
  end;
  if DWindow.FControlStyle = dsTop then begin
    DControls.Add(dcon);
    exit;
  end
  else if DWindow.FControlStyle = dsNone then begin
    for i := DControls.Count - 1 downto 0 do begin
      if TDControl(DControls[i]) is TDWindow then begin
        DWindow := TDWindow(DControls[i]);
        if (DWindow.FControlStyle <> dsTop) then begin
          if i = (DControls.Count - 1) then
            DControls.Add(dcon)
          else begin
            DControls.Insert(i + 1, dcon);
          end;
          exit;
        end;
      end;
    end;
  end;
  DControls.Add(dcon);
end;

function TDControl.CheckTab: Boolean;
var
  TabControl, TopControl: TDControl;
  I: Integer;
  boMy: Boolean;
begin
 boMy := False;
  Result := False;
  TopControl := nil;
  if DParent = nil then
    exit;
  for I := 0 to DParent.DTabControls.Count - 1 do begin
    TabControl := TDControl(DParent.DTabControls.Items[I]);
    if (TopControl = nil) and (TabControl.Visible) then TopControl := TabControl;

   if not boMy then begin
      if TabControl = self then
        boMy := True;
    end  else begin
      if TabControl.Visible then begin
        TabControl.SetFocus;
        exit;
      end;
    end;
  end;
  if TopControl <> nil then
    TopControl.SetFocus;
   
end;

function TDControl.InRange(x, y: integer): Boolean;
var
  boinrange: Boolean;
  d: TDXTexture;
begin
  if  (x >= Left) and (x < Left + Width) and (y >= Top) and (y < Top + Height) then begin
    boinrange := TRUE;
    if Assigned(FOnInRealArea) then
      FOnInRealArea(self, x - Left, y - Top, boinrange)
    else if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        if d.Pixels[x - Left, y - Top] <= 0 then
          boinrange := FALSE;
    end;
    Result := boinrange;
  end
  else
    Result := FALSE;
end;

procedure TDControl.IsVisible(flag: Boolean);
var
  I: Integer;
begin
  for i := 0 to DControls.Count - 1 do
    TDControl(DControls[i]).IsVisible(flag);
  FIsHide := not flag;
  if not (csReading in ComponentState) then begin
    if Assigned(FOnVisible) then
      FOnVisible(Self, flag);
  end;
end;

function TDControl.KeyPress(var Key: Char): Boolean;
begin
  Result := FALSE;
   if (KeyControl = self) then begin
      if Assigned(FOnKeyPress) then
        FOnKeyPress(self, Key);
       Result := TRUE;
   end;
   if (FocusedControl=self) and EndKeyRead then begin
      if Assigned (FOnKeyPress) then FOnKeyPress (self, Key);
      Result := TRUE;
   end;
end;


function TDControl.KeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;
  
  if (KeyControl = self) then begin
    if Assigned(FOnKeyUp) then
      FOnKeyUp(self, Key, Shift);
    Result := TRUE;
  end;
end;

function TDControl.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;
  if (KeyControl = self) then begin
    KeyDownControl := Self;
    if Assigned(FOnKeyDown) then
      FOnKeyDown(self, Key, Shift);
    Result := TRUE;
  end;
   if (FocusedControl=self) and EndKeyRead then begin
      if Assigned (FOnKeyDown) then FOnKeyDown (self, Key, Shift);
      Result := TRUE;
   end;  
end;


function TDControl.CanFocusMsg: Boolean;
begin
  if (MouseCaptureControl = nil) or ((MouseCaptureControl <> nil) and
    ((MouseCaptureControl = self) or (MouseCaptureControl = DParent))) then
    Result := TRUE
  else
    Result := FALSE;
end;

function TDControl.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  i: integer;
  al, at: integer;
  boTemp: Boolean;
begin
  Result := FALSE;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).MouseMove(Shift, X - Left, Y - Top) then begin
        Result := TRUE;
        if ((SpotX <> X) or (SpotY <> Y)) and Result and FFloating and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
          al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
          at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
          if FDParent.FCaption = 'DBackground' then begin
          if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
            al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
          if al > (GUIFScreenWidth - 60) then
            al := (GUIFScreenWidth - 60);
          if at + Height < WINTOP then
            at := WINTOP - Height;
          if at  > (GUIFScreenHeight - 60) then
            at := (GUIFScreenHeight - 60) ;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;
        end;
        if DXFloating then begin
          if ((SpotX <> X) or (SpotY <> Y)) and Result  and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
            al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
            at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
            if FDParent.FCaption = 'DBackground' then begin
            if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
              al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
            if al > (GUIFScreenWidth - 60) then
              al := (GUIFScreenWidth - 60);
            if at + Height < WINTOP then
              at := WINTOP - Height;
            if at  > (GUIFScreenHeight - 60) then
              at := (GUIFScreenHeight - 60) ;
            end;
            Left := al;
            Top := at;
            SpotX := X;
            SpotY := Y;
          end;
        end;
        exit;
      end;

  if (MouseCaptureControl <> nil) then begin
    if (MouseCaptureControl = self) then begin
      if Assigned(FOnMouseMove) then
        FOnMouseMove(self, Shift, X, Y);
      Result := TRUE;
        if ((SpotX <> X) or (SpotY <> Y)) and Result and FFloating and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
          al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
          at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
          if FDParent.FCaption = 'DBackground' then begin
          if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
            al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
          if al > (GUIFScreenWidth - 60) then
            al := (GUIFScreenWidth - 60);
          if at + Height < WINTOP then
            at := WINTOP - Height;
          if at  > (GUIFScreenHeight - 60) then
            at := (GUIFScreenHeight - 60) ;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;
        end;
     if DXFloating then begin
        if ((SpotX <> X) or (SpotY <> Y)) and Result  and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
          al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
          at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
          if FDParent.FCaption = 'DBackground' then begin
          if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
            al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
          if al > (GUIFScreenWidth - 60) then
            al := (GUIFScreenWidth - 60);
          if at + Height < WINTOP then
            at := WINTOP - Height;
          if at  > (GUIFScreenHeight - 60) then
            at := (GUIFScreenHeight - 60) ;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;
        end;
     end;
    end;
    exit;
  end;

  if Background then begin
    if (MouseEntryControl <> nil) and (MouseEntryControl <> self) then begin
      MouseEntryControl.FMouseEntry := msOut;
      if Assigned(MouseEntryControl.FOnMouseEntry) then
        MouseEntryControl.FOnMouseEntry(MouseEntryControl,
          MouseEntryControl.FMouseEntry);
      MouseEntryControl := nil;
    end;
    if (MouseEntryControl = nil) then begin
      MouseEntryControl := Self;
      FMouseEntry := msIn;
      if Assigned(FOnMouseEntry) then
        FOnMouseEntry(Self, FMouseEntry);
    end;
    exit;
  end;
  if InRange(X, Y) then begin
    if (MouseEntryControl <> nil) and (MouseEntryControl <> self) then begin
      MouseEntryControl.FMouseEntry := msOut;
      if Assigned(MouseEntryControl.FOnMouseEntry) then
        MouseEntryControl.FOnMouseEntry(MouseEntryControl,
          MouseEntryControl.FMouseEntry);
      MouseEntryControl := nil;
    end;
    if (MouseEntryControl = nil) then begin
      MouseEntryControl := Self;
      FMouseEntry := msIn;
      if Assigned(FOnMouseEntry) then
        FOnMouseEntry(MouseEntryControl, FMouseEntry);
    end;
    if Assigned(FOnMouseMove) then
      FOnMouseMove(self, Shift, X, Y);
        if ((SpotX <> X) or (SpotY <> Y)) and Result and FFloating and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
          al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
          at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
          if FDParent.FCaption = 'DBackground' then begin
          if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
            al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
          if al > (GUIFScreenWidth - 60) then
            al := (GUIFScreenWidth - 60);
          if at + Height < WINTOP then
            at := WINTOP - Height;
          if at  > (GUIFScreenHeight - 60) then
            at := (GUIFScreenHeight - 60) ;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;
        end;

   if DXFloating then begin
        if ((SpotX <> X) or (SpotY <> Y)) and Result  and (ssLeft in Shift) and (MouseCaptureControl = self)then begin   //如果记录发生变化（鼠标移动了）
          al := Left + (X - SpotX);  //控件本身Left + (所在坐标 - 原本鼠标位置)
          at := Top + (Y - SpotY);   //控件本身Top + (所在坐标 - 原本鼠标位置)
          if FDParent.FCaption = 'DBackground' then begin
          if al + Width < WINLEFT then//如果 记录的坐标 + 控件的宽度 小于 60
            al := WINLEFT - Width;    //临时变量 等于 60 - 控件的宽度
          if al > (GUIFScreenWidth - 60) then
            al := (GUIFScreenWidth - 60);
          if at + Height < WINTOP then
            at := WINTOP - Height;
          if at  > (GUIFScreenHeight - 60) then
            at := (GUIFScreenHeight - 60) ;
          end;
          Left := al;
          Top := at;
          SpotX := X;
          SpotY := Y;
        end;
   end;



    Result := TRUE;
  end;
end;

function TDControl.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
var
  i: integer;
begin
  Result := FALSE;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).MouseDown(Button, Shift, X - Left, Y - Top) then begin
        Result := TRUE;
        SpotX := X;
        SpotY := Y;
        exit;
      end;
  if Background then begin
    if Assigned(FOnBackgroundClick) then begin
      WantReturn := FALSE;
      FOnBackgroundClick(self);
      if WantReturn then begin
        SpotX := X;
        SpotY := Y;
        Result := TRUE;
      end;
    end;
    ReleaseDFocus;
    exit;
  end;
  if CanFocusMsg then begin
    if InRange(X, Y) or (MouseCaptureControl = self) then begin
      if Assigned(FOnMouseDown) then
        FOnMouseDown(self, Button, Shift, X, Y);
      if FMouseFocus  then SetDFocus(self);
      Result := TRUE;
      SpotX := X;
      SpotY := Y;
    end;
  end;
end;

function TDControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
var
  i: integer;
begin
  Result := FALSE;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).MouseUp(Button, Shift, X - Left, Y - Top) then begin
        Result := TRUE;
        exit;
      end;

  if (MouseCaptureControl <> nil) then begin
    if (MouseCaptureControl = self) then begin
      if Assigned(FOnMouseUp) then
        FOnMouseUp(self, Button, Shift, X, Y);
      Result := TRUE;
    end;
    exit;
  end;

  if Background then
    exit;
  if InRange(X, Y) then begin

    if Assigned(FOnMouseUp) then
      FOnMouseUp(self, Button, Shift, X, Y);
    Result := TRUE;
  end;
end;

function TDControl.MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean;
var
  i: integer;
begin
  Result := False;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).MouseWheel(Shift, Wheel, X - Left, Y - Top) then begin
        Result := TRUE;
        exit;
      end;

  if FWheelDControl <> nil then begin
    FWheelDControl.MouseWheel(Shift, Wheel, X - Left, Y - Top);
    Result := True;
  end;
end;

function TDControl.DblClick(X, Y: integer): Boolean;
var
  i: integer;
begin
  Result := FALSE;
  if (MouseCaptureControl <> nil) then begin 
    if (MouseCaptureControl = self) then begin
      if Assigned(FOnDblClick) then
        FOnDblClick(self);
      Result := TRUE;
    end;
    exit;
  end;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).DblClick(X - Left, Y - Top) then begin
        Result := TRUE;
        exit;
      end;
  if Background then
    exit;
  if InRange(X, Y) then begin
    if Assigned(FOnDblClick) then
      FOnDblClick(self);
    Result := TRUE;
  end;
end;

function TDControl.Click(X, Y: integer): Boolean;
var
  i: integer;
begin
  Result := FALSE;
  if (MouseCaptureControl <> nil) then begin 
    if (MouseCaptureControl = self) then begin
      if Assigned(FOnClick) then
        FOnClick(self, X, Y);
      Result := TRUE;
    end;
    exit;
  end;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).Click(X - Left, Y - Top) then begin
        Result := TRUE;
        exit;
      end;
  if Background then
    exit;
  if InRange(X, Y) then begin
    if Assigned(FOnClick) then
      FOnClick(self, X, Y);
    Result := TRUE;
  end;
end;

procedure TDControl.CloseSurface;
var
  i: integer;
begin
  for i := DControls.Count - 1 downto 0 do
    TDControl(DControls[i]).CloseSurface();

  if FSurface <> nil then begin
    FSurface.Free;
    FSurface := nil;
  end;
end;

procedure TDControl.SetImgIndex(Lib: TWMImages; index: integer);
var
  d: TDXTexture;
begin
  
  if Lib <> nil then begin
    d := Lib.Images[index];
    WLib := Lib;
    DFileName:= Lib.FileName;
    FaceIndex := index;
    if d <> nil then begin
      Width := d.Width;
      Height := d.Height;
    end;
  end;
end;


procedure TDControl.SetVisible(flag: Boolean);
begin
  if FVisible <> flag then
    IsVisible(flag);
    FVisible := flag;
   if FVisibleX  <> flag then
    IsVisible(flag);
  FVisibleX := flag;
end;

procedure TDControl.DirectPaint(dsurface: TDXDrawCanvas);
var
  i: integer;
  d: TDXTexture;
  dc :TRect;
begin
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface)
  else if WLib <> nil then begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
//     if DXChecked=True then
//      g_DXCanvas.TextOut(SurfaceX(Left + d.Width div 2),
//                  SurfaceY(Top + d.Height div 2),
//                  NameString,
//                  $FF00FFFF);
  end;

  for i := 0 to DControls.Count - 1 do
    if TDControl(DControls[i]).Visible then
      TDControl(DControls[i]).DirectPaint(dsurface);

  if Assigned(FOnEndDirectPaint) then
    FOnEndDirectPaint(self, dsurface);
    if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

procedure TDControl.Enter();
begin
  if Assigned(FOnEnter) then
    FOnEnter(Self)
end;

function TDControl.Focused: Boolean;  //20080624
begin
  if FocusedControl = Self then Result := True
  else Result := False;
end;



function TDControl.EscClose: Boolean;
var
  i: integer;
begin
  Result := FALSE;
  for i := DControls.Count - 1 downto 0 do
    if TDControl(DControls[i]).Visible then
      if TDControl(DControls[i]).EscClose then begin
        Result := TRUE;
        exit;
      end;
end;

constructor TDButton.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Downed := FALSE;
  FOnClick := nil;
  Moveed := FALSE;
  
  FClickSound := csNone;
end;

function TDButton.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := inherited MouseMove(Shift, X, Y);
  Moveed := Result;
  if (not Background) and (not Result) then begin
    Result := inherited MouseMove(Shift, X, Y);
    if MouseCaptureControl = self then
      if InRange(X, Y) then
        Downed := TRUE
      else
        Downed := FALSE;
  end;
end;

procedure TDButton.DirectPaint(dsurface: TDXDrawCanvas);
var
  d: TDXTexture;
  i: integer;
  dc :TRect;
begin
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface)
  else if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
  end;

  for i := 0 to DControls.Count - 1 do
    if TDControl(DControls[i]).Visible then
      TDControl(DControls[i]).DirectPaint(dsurface);
  if Assigned(FOnEndDirectPaint) then
    FOnEndDirectPaint(self, dsurface);
    if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;
//这个是鼠标按下的事件
function TDButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseDown(Button, Shift, X, Y) and FEnabled then begin
    if (not Background) and (MouseCaptureControl = nil) then begin
    if  TranFrame=False then  //2017.6.16 修正UI编辑器开发者模式不执行鼠标事件
      Downed := TRUE;
      SetDCapture(self);
    end;
    Result := TRUE;
  
  end;
end;

function TDButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseUp(Button, Shift, X, Y) and FEnabled then begin

    ReleaseDCapture;
    if not Background then begin
      if Downed and InRange(X, Y) then begin

        if Assigned(FOnClickSound) then
          FOnClickSound(self, FClickSound);
        if Assigned(FOnClick) then
          FOnClick(self, X, Y);
      end;
    end;
    Downed := FALSE;
    Result := TRUE;
    exit;
   
  end
  else begin
    ReleaseDCapture;
    Downed := FALSE;
  end;
end;



constructor TDGrid.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FColCount := 8;
  FRowCount := 5;
  FColWidth := 36;
  FRowHeight := 32;
  FOnGridSelect := nil;
  FOnGridMouseMove := nil;
  FOnGridPaint := nil;
  FColoffset := 0;
  FRowoffset := 0;
  FSelectCell.X := -1;
  FSelectCell.Y := -1;
end;

function TDGrid.GetColRow(x, y: integer; var acol, arow: integer): Boolean;
var
  nX, nY: Integer;
begin
  Result := FALSE;
  if InRange(x, y) then begin
    nX := x - Left;
    nY := y - Top;
    acol := nX div (FColWidth + FColoffset);
    arow := nY div (FRowHeight + FRowoffset);
    if (nX - (FColWidth + FColoffset) * (acol) - FColWidth <= 0) and
      (nY - (FRowHeight + FRowoffset) * (arow) - FRowHeight <= 0) then
      Result := TRUE;
  end;
end;

function TDGrid.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
var
  acol, arow: integer;
begin
  Result := FALSE;
  if mbLeft = Button then begin
    if GetColRow(X, Y, acol, arow) then begin
      FSelectCell.X := acol;
      FSelectCell.Y := arow;
      DownPos.X := X;
      DownPos.Y := Y;
      SetDCapture(self);
      Result := TRUE;
    end;
  end;
end;

function TDGrid.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  acol, arow: integer;
begin
  Result := FALSE;
  if InRange(X, Y) then begin
    if GetColRow(X, Y, acol, arow) then begin
      if Assigned(FOnGridMouseMove) then
        FOnGridMouseMove(Self,{ X, Y, }acol, arow, Shift);
    end;
    Result := TRUE;
  end;
end;

function TDGrid.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
var
  acol, arow: integer;
begin
  Result := FALSE;
  if mbLeft = Button then begin
    if GetColRow(X, Y, acol, arow) then begin
      if (FSelectCell.X = acol) and (FSelectCell.Y = arow) then begin
        Col := acol;
        Row := arow;
        if Assigned(FOnGridSelect) then
          FOnGridSelect(Self,{ X, Y, }acol, arow, Shift);
      end;
      Result := TRUE;
    end;
    ReleaseDCapture;
    FSelectCell.X := -1;
    FSelectCell.Y := -1;
  end;
end;

function TDGrid.Click(X, Y: integer): Boolean;
begin
  Result := FALSE;
  
end;

procedure TDGrid.DirectPaint(dsurface: TDXDrawCanvas);
var
  i, j: integer;
  rc: TRect;
  dc :TRect;
begin
  if Assigned(FOnGridPaint) then
    for i := 0 to FRowCount - 1 do
      for j := 0 to FColCount - 1 do begin
        rc.Top := Top + i * FRowHeight + i * FRowoffset;
        rc.Left := Left + j * FColWidth + j * FColoffset;
        rc.Right := rc.Left + FColWidth;
        rc.Bottom := rc.Top + FRowHeight;

        if (FSelectCell.Y = i) and (FSelectCell.X = j) then
          FOnGridPaint(self, j, i, rc, [gdSelected], dsurface)
        else
          FOnGridPaint(self, j, i, rc, [], dsurface);
      end;
   if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;

end;



constructor TDWindow.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FEscClose := False;
  
  Width := 120;
  Height := 120;
  FControlStyle := dsNone;
end;

procedure TDWindow.SetVisible(flag: Boolean);
begin
  if FVisible <> flag then begin
    IsVisible(flag);
    if flag and FMouseFocus  then
      SetDFocus(self)
    else
    if FocusedControl = self then
      ReleaseDFocus
  end;
  FVisible := flag;

  if FVisibleX <> flag then begin
    IsVisible(flag);
    if flag and FMouseFocus  then
      SetDFocus(self)
    else
    if FocusedControl = self then
      ReleaseDFocus
  end;
  FVisibleX := flag;
  
  if DParent <> nil then
    DParent.ChangeChildOrder(self);


end;

function TDWindow.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := inherited MouseMove(Shift, X, Y);
end;

procedure TDWindow.DirectPaint(dsurface: TDXDrawCanvas);
var
  i: integer;
  d: TDXTexture;
  dc :TRect;
begin
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface)
  else if WLib <> nil then begin
    d := WLib.Images[FaceIndex];
    if d <> nil then
      dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;
  for i := 0 to DControls.Count - 1 do
    if TDControl(DControls[i]).Visible then
      TDControl(DControls[i]).DirectPaint(dsurface);

  if Assigned(FOnEndDirectPaint) then
    FOnEndDirectPaint(self, dsurface);
   if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

function TDWindow.EscClose: Boolean;
begin
  Result := inherited EscClose;
  if (not Result) and FEscClose then begin
    Visible := False;
    Result := True;
  end;
end;

function TDWindow.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
begin
  Result := inherited MouseDown(Button, Shift, X, Y);
  if Result then begin
    
    if DParent <> nil then
      DParent.ChangeChildOrder(self);
    
    SpotX := X;
    SpotY := Y;
  end;
end;

function TDWindow.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
begin
  Result := inherited MouseUp(Button, Shift, X, Y);
end;

procedure TDWindow.Show;
begin
  Visible := TRUE;
  if DParent <> nil then
    DParent.ChangeChildOrder(self);
  
  if FMouseFocus then SetDFocus(self);
end;

procedure TDWindow.TopShow();
begin
  Show;
  TopDWindow := self;
end;

function TDWindow.ShowModal: integer;
begin
  Result := 0; 
  Visible := TRUE;
  ModalDWindow := self;
  if FMouseFocus  then
    SetDFocus(self);
end;



constructor TDWinManager.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  DWinList := TList.Create;
  MouseCaptureControl := nil;
  FocusedControl := nil;
  KeyControl := nil;
  MouseEntryControl := nil;
  ModalDWindow := nil;
end;

destructor TDWinManager.Destroy;
begin
  inherited Destroy;
end;

procedure TDWinManager.ClearAll;
begin
  DWinList.Clear;
end;

procedure TDWinManager.AddDControl(dcon: TDControl; visible: Boolean);
begin
  dcon.Visible := visible;
  DWinList.Add(dcon);
end;

procedure TDWinManager.DelDControl(dcon: TDControl);
var
  i: integer;
begin
  for i := 0 to DWinList.Count - 1 do
    if DWinList[i] = dcon then begin
      DWinList.Delete(i);
      break;
    end;
end;

function TDWinManager.KeyPress(var Key: Char): Boolean;
begin
  Result := FALSE;
  
  if Key = #9 {VK_TAB} then begin
    if KeyControl <> nil then begin
      if KeyControl.Visible and KeyControl.Enabled and (not KeyControl.IsHide) then begin
        if KeyControl.CheckTab then begin

        end;
      end
      else
        ReleaseDKocus;
    end;
  end;
  if KeyDownControl <> nil then begin
    if KeyDownControl.Visible and KeyDownControl.Enabled and (not KeyDownControl.IsHide) then
      KeyDownControl.KeyPress(Key);
    Result := True;
  end else
  if KeyControl <> nil then begin
    if KeyControl.Visible and KeyControl.Enabled and (not KeyControl.IsHide) then
      Result := KeyControl.KeyPress(Key)
    else
      ReleaseDKocus;
  end;
end;

function TDWinManager.KeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;
  if KeyDownControl <> nil then begin
    if KeyDownControl.Visible and KeyDownControl.Enabled and (not KeyDownControl.IsHide) then
      KeyDownControl.KeyUp(Key, Shift);
    Result := True;
  end else
  if KeyControl <> nil then begin
    if KeyControl.Visible and KeyControl.Enabled and (not KeyControl.IsHide) then
      Result := KeyControl.KeyUp(Key, Shift)
    else
      ReleaseDKocus;
  end;
  KeyDownControl := nil;
end;

function TDWinManager.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;
  if KeyControl <> nil then begin
    if KeyControl.Visible and KeyControl.Enabled and (not KeyControl.IsHide) then
      Result := KeyControl.KeyDown(Key, Shift)
    else
      ReleaseDKocus;
  end else if Key = 27{VK_ESCAPE--ESC} then begin
    Result := EscClose;
  end;
   if FocusedControl <> nil then begin
      if FocusedControl.Visible then
         Result := FocusedControl.KeyDown (Key, Shift)
      else
         ReleaseDFocus;
   end;
end;

function TDWinManager.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := FALSE;

//  if PopUpDWindow <> nil then begin
//    if PopUpDWindow.Visible then begin
//      with PopUpDWindow do
//        MouseMove(Shift, LocalX(X), LocalY(Y));
//      Result := True;
//      exit;
//    end
//    else
//      PopUpDWindow := nil;
//  end;

  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          MouseMove(Shift, LocalX(X), LocalY(Y));
        Result := TRUE;
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      ModalDWindow.MouseMove(Shift, ModalDWindow.LocalX(X), ModalDWindow.LocalY(Y));
      Result := TRUE;
      exit;
    end
    else
      MOdalDWindow := nil;
  end;
  if MouseCaptureControl <> nil then begin
      Result := MouseCaptureControl.MouseMove(Shift, MouseCaptureControl.LocalX(X), MouseCaptureControl.LocalY(Y));
        if (Result <> True )then   begin
        MouseCaptureControl :=nil;
      end;
       Result := TRUE;
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).MouseMove(Shift, X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

function TDWinManager.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y:
  Integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := FALSE;
//  if PopUpDWindow <> nil then begin
//    if PopUpDWindow.Visible then begin
//      with PopUpDWindow do
//        MouseDown(Button, Shift, LocalX(X), LocalY(Y));
//      Result := TRUE;
//      exit;
//    end else PopUpDWindow := nil;
//  end;

  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          MouseDown(Button, Shift, LocalX(X), LocalY(Y));
        Result := TRUE;
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      with ModalDWindow do
        MouseDown(Button, Shift, LocalX(X), LocalY(Y));
      Result := TRUE;
      exit;
    end
    else
      ModalDWindow := nil;
  end;

  if TopDWindow <> nil then begin
    if TopDWindow.Visible then begin
      with TopDWindow do
        MouseDown(Button, Shift, LocalX(X), LocalY(Y));
      Result := TRUE;
      exit;
    end else TopDWindow := nil;
  end;

  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := MouseDown(Button, Shift, LocalX(X), LocalY(Y));
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).MouseDown(Button, Shift, X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

function TDWinManager.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := TRUE;


  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          Result := MouseUp(Button, Shift, LocalX(X), LocalY(Y));
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      with ModalDWindow do
        Result := MouseUp(Button, Shift, LocalX(X), LocalY(Y));
      exit;
    end
    else
      ModalDWindow := nil;
  end;

  if TopDWindow <> nil then begin
    if TopDWindow.Visible then begin
      with TopDWindow do
        Result := MouseUp(Button, Shift, LocalX(X), LocalY(Y));
      if not Result then begin
        Result := True;
        TopDWindow.Visible := False;
        TopDWindow := nil;
      end;
      exit;
    end else TopDWindow := nil;
  end;
  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := MouseUp(Button, Shift, LocalX(X), LocalY(Y));
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).MouseUp(Button, Shift, X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

function TDWinManager.MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := FALSE;



  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          MouseWheel(Shift, Wheel, LocalX(X), LocalY(Y));
        Result := TRUE;
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      with ModalDWindow do
        MouseWheel(Shift, Wheel, LocalX(X), LocalY(Y));
      Result := TRUE;
      exit;
    end
    else
      MOdalDWindow := nil;
  end;
  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := MouseWheel(Shift, Wheel, LocalX(X), LocalY(Y));
  end
  else
  if FocusedControl <> nil then begin
    with FocusedControl do
      Result := MouseWheel(Shift, Wheel, LocalX(X), LocalY(Y));
  end;

    {for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).MouseWheel(Shift, Wheel, X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;   }
end;

function TDWinManager.DblClick(X, Y: integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := TRUE;

  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          Result := DblClick(LocalX(X), LocalY(Y));
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      with ModalDWindow do
        Result := DblClick(LocalX(X), LocalY(Y));
      exit;
    end
    else
      ModalDWindow := nil;
  end;
  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := DblClick(LocalX(X), LocalY(Y));
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).DblClick(X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

function TDWinManager.Click(X, Y: integer): Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := TRUE;

  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        with MDWindow do
          Result := Click(LocalX(X), LocalY(Y));
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      with ModalDWindow do
        Result := Click(LocalX(X), LocalY(Y));
      exit;
    end
    else
      ModalDWindow := nil;
  end;
  if TopDWindow <> nil then begin
    if TopDWindow.Visible then begin
      with TopDWindow do
        Click(LocalX(X), LocalY(Y));
      exit;
    end else TopDWindow := nil;
  end;
  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := Click(LocalX(X), LocalY(Y));
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).Click(X, Y) then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

procedure TDWinManager.CloseModalShow();
var
  i: integer;
begin
  for I := 0 to ModalDWindowList.Count - 1 do begin
    TDModalWindow(ModalDWindowList[i]).Visible := False;
  end;
  ModalDWindowList.Clear;
  if ModalDWindow <> nil then begin
    ModalDWindow.Visible := False;
    ModalDWindow := nil;
  end;
end;

procedure TDWinManager.CloseSurface;
var
  i: integer;
begin

  CloseModalShow();
  for i := 0 to DWinList.Count - 1 do
    TDControl(DWinList[i]).CloseSurface();
end;

procedure TDWinManager.DirectPaint(dsurface: TDXDrawCanvas);
var
  i: integer;
begin
   if DWinList.Count > 0 then //20080629
   for i:=0 to DWinList.Count-1 do begin
      if TDControl(DWinList[i]).Visible then begin
         TDControl(DWinList[i]).DirectPaint (dsurface);
      end;
   end;
   if ModalDWindow <> nil then begin
      if ModalDWindow.Visible then
         with ModalDWindow do
            DirectPaint (dsurface);
   end;


end;



function TDWinManager.EscClose: Boolean;
var
  i: integer;
  MDWindow: TDModalWindow;
begin
  Result := FALSE;



  if ModalDWindowList.Count > 0 then begin
    for I := ModalDWindowList.Count - 1 downto 0 do begin
      MDWindow := TDModalWindow(ModalDWindowList[i]);
      if MDWindow.Visible then begin
        MDWindow.Visible := False;
        ModalDWindowList.delete(i);
        Result := TRUE;
        exit;
      end else ModalDWindowList.delete(i);
    end;
  end;

  if ModalDWindow <> nil then begin
    if ModalDWindow.Visible then begin
      ModalDWindow.Visible := False;
      ModalDWindow := nil;
      Result := TRUE;
      exit;
    end
    else
      ModalDWindow := nil;
  end;

  if TopDWindow <> nil then begin
    if TopDWindow.Visible then begin
      TopDWindow.Visible := False;
      TopDWindow := nil;
      Result := True;
      exit;
    end else TopDWindow := nil;
  end;

  if MouseCaptureControl <> nil then begin
    with MouseCaptureControl do
      Result := MouseCaptureControl.EscClose;
  end
  else
    for i := 0 to DWinList.Count - 1 do begin
      if TDControl(DWinList[i]).Visible then begin
        if TDControl(DWinList[i]).EscClose then begin
          Result := TRUE;
          break;
        end;
      end;
    end;
end;

constructor TDCheckBox.Create(AOwner: TComponent);
begin
  inherited;
  FChecked := False;
  FFontSpace := 3;
  FWidth := 0;
  FHeight := 0;
  FOnClick := nil;
  Moveed := False;

  Chackop := false;
  
  FOffsetLeft := 0;
  FOffsetTop := 0;
  FDFColor := $C4C9BA;
  FDFMoveColor := $C5D2BD;
  FDFEnabledColor := $C5D2BD;
  FDFDownColor := clWhite;
  FDFBackColor := $8;
  FOnCheckedChange := nil;
end;

procedure TDCheckBox.DirectPaint(dsurface: TDXDrawCanvas);
var
  d: TDXTexture;
  dc :TRect;
begin
  if FChangeCaption then begin
    FWidth := g_DXCanvas.TextWidth(Caption);
    FHeight := g_DXCanvas.TextHeight(Caption);
    FChangeCaption := False;
  end;
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface)
  else if WLib <> nil then begin
    if Checked then begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end
    else begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
    end;
    if d <> nil then begin
      with g_DXCanvas do begin
        if Checked then
          TextOut(SurfaceX(Left) + d.Width + FFontSpace + FOffsetLeft,
                  SurfaceY(Top) + d.Height div 2 - FHeight div 2 + FOffsetTop,
                  Caption,
                  FDFDownColor)
        else
          TextOut(SurfaceX(Left) + d.Width + FFontSpace + FOffsetLeft,
                  SurfaceY(Top) + d.Height div 2 - FHeight div 2 + FOffsetTop,
                  Caption,
                  FDFColor);
      end;
    end;
  end;
   if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

function TDCheckBox.InRange(x, y: integer): Boolean;
var
  boinrange: Boolean;
  nWidth, nHeight: Integer;
begin
  nWidth := FWidth + FFontSpace + Width;
  nHeight := _MAX(Height, FHeight);
  if (x >= Left) and (x < Left + nWidth + FOffsetLeft) and (y >= Top) and (y < Top + nHeight) then begin
    boinrange := TRUE;
    if Assigned(FOnInRealArea) then
      FOnInRealArea(self, x - Left, y - Top, boinrange);
    Result := boinrange;
  end
  else
    Result := FALSE;
end;

function TDCheckBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseDown(Button, Shift, X, Y) and FEnabled then begin
    if (not Background) and (MouseCaptureControl = nil) then begin
      SetDCapture(self);
    end;
    Result := TRUE;
  end;
end;

function TDCheckBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseUp(Button, Shift, X, Y) and FEnabled then begin
    ReleaseDCapture;
    if not Background then begin
      if InRange(X, Y) then begin
        FChecked := not FChecked;
        if Assigned(FOnClick) then
          FOnClick(self, X, Y);
        if Assigned(FOnCheckedChange) then
          FOnCheckedChange(Self);
      end;
    end;
    Result := TRUE;
    exit;
  end
  else begin
    ReleaseDCapture;
  end;
end;

procedure TDUpDown.ButtonMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  FClickTime := GetTickCount;
  if Sender = FUpButton then begin
    if FPosition >= FMovePosition then
      Dec(FPosition, FMovePosition)
    else
      FPosition := 0;
    FAddTop := Round(FMaxLength / FMaxPosition * FPosition);
    if Assigned(FOnPositionChange) then
      FOnPositionChange(Self);
  end
  else if Sender = FDownButton then begin
    if (FPosition + FMovePosition) <= FMaxPosition then
      Inc(FPosition, FMovePosition)
    else
      FPosition := FMaxPosition;
    FAddTop := Round(FMaxLength / FMaxPosition * FPosition);
    if Assigned(FOnPositionChange) then
      FOnPositionChange(Self);
  end
  else if Sender = FMoveButton then begin
    StopY := Y;
    FStopY := FAddTop;
  end;
  if Assigned(FOnMouseDown) then
    FOnMouseDown(self, Button, Shift, X, Y);
end;

procedure TDUpDown.ButtonMouseMove(Sender: TObject; Shift: TShiftState; X, Y:
  Integer);
var
  nIdx: Integer;
  OldPosition: Integer;
  nY: Integer;
  DButton: TDButton;
begin
  if Sender = FUpButton then begin
    DButton := TDButton(Sender);
    if (DButton.Downed) and ((GetTickCount - FClickTime) > 100) then
      ButtonMouseDown(Sender, mbLeft, Shift, X, Y);
  end
  else if Sender = FDownButton then begin
    DButton := TDButton(Sender);
    if (DButton.Downed) and ((GetTickCount - FClickTime) > 100) then
      ButtonMouseDown(Sender, mbLeft, Shift, X, Y);
  end
  else if Sender = FMoveButton then begin
    if (StopY < 0) or (StopY = y) then begin
      if Assigned(FOnMouseMove) then
        FOnMouseMove(self, Shift, X, Y);
      Exit;
    end;

    nY := Y - StopY;
    FAddTop := FStopY + nY;
    if FAddTop < 0 then
      FAddTop := 0;
    if FAddTop > FMaxLength then
      FAddTop := FMaxLength;

    OldPosition := FPosition;
    nIdx := Round(FAddTop / (FMaxLength / FMaxPosition));
    if nIdx <= 0 then
      FPosition := 0
    else if nIdx >= FMaxPosition then
      FPosition := FMaxPosition
    else
      FPosition := nIdx;
    if OldPosition <> FPosition then
      if Assigned(FOnPositionChange) then
        FOnPositionChange(Self);
  end;
  if Assigned(FOnMouseMove) then
    FOnMouseMove(self, Shift, X, Y);
end;

procedure TDUpDown.ButtonMouseUp(Sender: TObject; Button: TMouseButton; Shift:
  TShiftState; X, Y: Integer);
begin
  StopY := -1;
  if Assigned(FOnMouseUp) then
    FOnMouseUp(self, Button, Shift, X, Y);
end;

constructor TDUpDown.Create(AOwner: TComponent);
begin
  inherited;
  FUpButton := TDButton.Create(nil);
  FDownButton := TDButton.Create(nil);
  FMoveButton := TDButton.Create(nil);
  
  
  SetButton(UpButton);
  SetButton(DownButton);
  SetButton(MoveButton);

  FOffset := 1;
  FBoMoveShow := False;
  FboMoveFlicker := False;
  FboNormal := False;

  FMovePosition := 1;
  FPosition := 0;
  FMaxPosition := 0;
  FMaxLength := 0;
  FTop := 0;
  FAddTop := 0;
  StopY := -1;
  FWheelDControl := Self;
end;

destructor TDUpDown.Destroy;
begin
  FUpButton.Free;
  FDownButton.Free;
  FMoveButton.Free;
  inherited;
end;

procedure TDUpDown.DirectPaint(dsurface: TDXDrawCanvas);
var
  d: TDXTexture;
  dc, rc: TRect;
begin
  if WLib <> nil then begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      dc.Left := SurfaceX(Left);
      dc.Top := SurfaceY(Top);
      dc.Right := SurfaceX(left + Width);
      dc.Bottom := SurfaceY(top + Height);
      rc.Left := 0;
      rc.Top := 0;
      rc.Right := d.ClientRect.Right;
      rc.Bottom := d.ClientRect.Bottom;
      dsurface.StretchDraw(dc, rc, d, True);
    end;
    if FUpButton <> nil then begin
      with FUpButton do begin
        if FboNormal then begin
          Left := FOffset;
          Top := 0;
        end else begin
          Left := FOffset;
          Top := FOffset;
        end;
        if Downed then begin
          d := WLib.Images[FaceIndex + 1 + Integer(FBoMoveShow)];
        end
        else if MouseEntry = msIn then begin
          d := WLib.Images[FaceIndex + Integer(FBoMoveShow)];
        end
        else begin
          d := WLib.Images[FaceIndex];
        end;
        if d <> nil then begin
          FTop := d.Height + Top;
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        end;
      end;
    end;
    if FDownButton <> nil then begin
      with FDownButton do begin
        if FboNormal then begin
          Left := FOffset;
          Top := Self.Height - d.Height;
        end else begin
          Left := FOffset;
          if FBoMoveShow then
            Top := Self.Height - d.Height + 1
          else
            Top := Self.Height - d.Height - 1;
        end;


        if Downed then begin
          d := WLib.Images[FaceIndex + 1 + Integer(FBoMoveShow)];
        end
        else if MouseEntry = msIn then begin
          d := WLib.Images[FaceIndex + Integer(FBoMoveShow)];
        end
        else begin
          d := WLib.Images[FaceIndex];
        end;
        if d <> nil then begin
          FMaxLength := Top - FTop;
          dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
        end;
      end;
    end;
    if FMoveButton <> nil then begin
      with FMoveButton do begin
        Left := FOffset;
        if FBoMoveShow then begin
          if Downed then begin
            d := WLib.Images[FaceIndex + 2];
          end
          else if MouseEntry = msIn then begin
            d := WLib.Images[FaceIndex + 1];
          end
          else begin
            if FboMoveFlicker and ((GetTickCount - AppendTick) mod 400 < 200) then begin
              d := WLib.Images[FaceIndex + 1];
            end else
              d := WLib.Images[FaceIndex];
          end;
          if (d <> nil) then begin
            Dec(FMaxLength, d.Height);
            Top := FTop + FAddTop;
            if FMaxPosition > 0 then
              dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end
        else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then begin
            Dec(FMaxLength, d.Height);
            Top := FTop + FAddTop;
            dsurface.Draw(SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, True);
          end;
        end;
      end;
    end;
  end;
  if Assigned(FOnEndDirectPaint) then
    FOnEndDirectPaint(self, dsurface);
    if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

function TDUpDown.MouseWheel(Shift: TShiftState; Wheel: TMouseWheel; X, Y: Integer): Boolean;
begin
  Result := True;
  if Wheel = mw_Up then
    ButtonMouseDown(FUpButton, mbLeft, Shift, X, Y)
  else if Wheel = mw_Down then
    ButtonMouseDown(FDownButton, mbLeft, Shift, X, Y);
end;

procedure TDUpDown.SetButton(Button: TDButton);
begin
  Button.DParent := Self;
  Button.OnMouseMove := ButtonMouseMove;
  Button.FWheelDControl := Self;
  Button.OnMouseDown := ButtonMouseDown;
  Button.OnMouseUp := ButtonMouseUp;
  AddChild(Button);
end;

procedure TDUpDown.SetMaxPosition(const Value: Integer);
var
  OldPosition: integer;
begin
  OldPosition := FMaxPosition;
  FMaxPosition := _Max(Value, 0);
  if OldPosition <> FMaxPosition then begin
    if FPosition > FMaxPosition then
      FPosition := FMaxPosition;
    if FMaxPosition > 0 then
      FAddTop := Round(FMaxLength / FMaxPosition * FPosition);
  end;
end;

procedure TDUpDown.SetPosition(value: Integer);
var
  OldPosition: integer;
begin
  OldPosition := FPosition;
  FPosition := _Max(Value, 0);
  if FPosition > FMaxPosition then
    FPosition := FMaxPosition;
  if OldPosition <> FPosition then begin
    if FMaxPosition > 0 then
      FAddTop := Round(FMaxLength / FMaxPosition * FPosition);
  end;
end;



constructor TDHooKKey.Create(AOwner: TComponent);
begin
  inherited;
  FShiftState := [];
  FKey := 0;
  FText := '';
  Color := clBlack;
  FrameColor := clSilver;
  FKeyFocus := True;
  FOnChange := nil;
  
  
end;

procedure TDHooKKey.DirectPaint(dsurface: TDXDrawCanvas);
var
  dc: TRect;
begin
  with g_DXCanvas do begin
    if FText <> '' then begin
      dc.Left := SurfaceX(Left + 3);
      dc.Top := SurfaceY(Top);
      dc.Right := SurfaceX(left + Width - 5);
      dc.Bottom := SurfaceY(top + Height);
      TextRect(dc, FText, Self.Font.Color, [tfSingleLine, tfCenter, tfVerticalCenter]);
    end;
  end;
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface);
    if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

function TDHooKKey.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := False;
  if (KeyControl = self) then begin
    KeyDownControl := Self;
    if Assigned(FOnKeyDown) then
      FOnKeyDown(self, Key, Shift);
    if Key <> 0 then begin
      if (Key = VK_BACK) or (Key = VK_DELETE) then begin
        FShiftState := [];
        FKey := 0;
        Key := 0;
        RefHookKeyStr();
      end
      else begin
        FShiftState := Shift;
        FKey := Key;
        Key := 0;
        RefHookKeyStr();
      end;
      if Assigned(FOnChange) then
        FOnChange(self);
    end;
    Result := True;
  end;
end;

function TDHooKKey.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseDown(Button, Shift, X, Y) then begin
    if (not Background) and (MouseCaptureControl = nil) then begin
      SetDCapture(self);
    end;
    Result := TRUE;
  end;
end;

function TDHooKKey.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseUp(Button, Shift, X, Y) then begin
    ReleaseDCapture;
    if not Background then begin
      if InRange(X, Y) then begin
        if Assigned(FOnClick) then
          FOnClick(self, X, Y);
      end;
    end;
    Result := TRUE;
    exit;
  end
  else begin
    ReleaseDCapture;
  end;
end;

procedure TDHooKKey.RefHookKeyStr;
var
  ShowStr: string;
begin
  ShowStr := '';
  if ssCtrl in FShiftState then
    ShowStr := 'Ctrl';

  if ssAlt in FShiftState then
    if ShowStr <> '' then
      ShowStr := ShowStr + '+Alt'
    else
      ShowStr := 'Alt';

  if ssShift in FShiftState then
    if ShowStr <> '' then
      ShowStr := ShowStr + '+Shift'
    else
      ShowStr := 'Shift';

  case FKey of
    VK_F1: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F1'
        else
          ShowStr := 'F1';
      end;
    VK_F2: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F2'
        else
          ShowStr := 'F2';
      end;
    VK_F3: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F3'
        else
          ShowStr := 'F3';
      end;
    VK_F4: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F4'
        else
          ShowStr := 'F4';
      end;
    VK_F5: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F5'
        else
          ShowStr := 'F5';
      end;
    VK_F6: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F6'
        else
          ShowStr := 'F6';
      end;
    VK_F7: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F7'
        else
          ShowStr := 'F7';
      end;
    VK_F8: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F8'
        else
          ShowStr := 'F8';
      end;
    VK_F9: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F9'
        else
          ShowStr := 'F9';
      end;
    VK_F10: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F10'
        else
          ShowStr := 'F10';
      end;
    VK_F11: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F11'
        else
          ShowStr := 'F11';
      end;
    VK_F12: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+F12'
        else
          ShowStr := 'F12';
      end;
    VK_TAB: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Tab'
        else
          ShowStr := 'Tab';
      end;
    VK_PAUSE: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Pause'
        else
          ShowStr := 'Pause';
      end;
    VK_HOME: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Home'
        else
          ShowStr := 'Home';
      end;
    VK_LEFT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Left'
        else
          ShowStr := 'Left';
      end;
    VK_UP: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Up'
        else
          ShowStr := 'Up';
      end;
    VK_RIGHT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Right'
        else
          ShowStr := 'Right';
      end;
    VK_DOWN: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Down'
        else
          ShowStr := 'Down';
      end;
    VK_SPACE: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Space'
        else
          ShowStr := 'Space';
      end;
    VK_CAPITAL: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+CapsLock'
        else
          ShowStr := 'CapsLock';
      end;
    VK_ESCAPE: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Esc'
        else
          ShowStr := 'Esc';
      end;
    VK_PRIOR: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Prior'
        else
          ShowStr := 'Prior';
      end;
    VK_NEXT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Next'
        else
          ShowStr := 'Next';
      end;
    VK_END: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+End'
        else
          ShowStr := 'End';
      end;
    VK_SELECT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Select'
        else
          ShowStr := 'Select';
      end;
    VK_PRINT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Print'
        else
          ShowStr := 'Print';
      end;
    VK_EXECUTE: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Execute'
        else
          ShowStr := 'Execute';
      end;
    VK_SNAPSHOT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Snapshot'
        else
          ShowStr := 'Snapshot';
      end;
    VK_INSERT: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Insert'
        else
          ShowStr := 'Insert';
      end;
    VK_HELP: begin
        if ShowStr <> '' then
          ShowStr := ShowStr + '+Help'
        else
          ShowStr := 'Help';
      end;
    VK_SHIFT,
      VK_CONTROL,
      VK_MENU: begin

      end
  else begin
      if ShowStr <> '' then
        ShowStr := ShowStr + '+' + Char(FKey)
      else
        ShowStr := Char(FKey);
    end;
  end;

  FText := ShowStr;
end;

procedure TDHooKKey.SetKey(Value: Word);
begin
  FKey := Value;
  RefHookKeyStr;
  
end;

procedure TDHooKKey.SetShiftState(Value: TShiftState);
begin
  FShiftState := Value;
  RefHookKeyStr;
  
end;



function TDEdit.ClearKey: Boolean;
begin
  Result := False;
  if (FStartX > -1) and (FStopX > -1) and (FStartX <> FStopX) then begin
    if FStartX > FStopX then begin
      Delete(FEditString, FStopX, FStartX - FStopX);
      FCaretPos := FStopX;
    end
    else begin
      Delete(FEditString, FStartX, FStopX - FStartX);
      FCaretPos := FStartX;
    end;
    if FCaretPos < FCaretStart then
      FCaretStart := FCaretPos;
    FStartX := -1;
    FStopX := -1;
    FCursor := deLeft;
    Result := True;
  end;
  FStartX := -1;
  FStopX := -1;
end;



constructor TDEdit.Create(AOwner: TComponent);
begin
  inherited;
  FOnChange := nil;
  Moveed := False;
  FKeyFocus := True;
  FCaretShowTime := GetTickCount;
  FrameColor := clSilver;
  FTimeShowColor := clWhite;
  FMaxLength := 0;
  FInputStr := '';
  bDoubleByte := False;
  KeyByteCount := 0;
  FCaretPos := 1;
  FCaretStart := 1;
  FCaretStop := 1;
  FCursor := deLeft;
  FStartX := -1;
  FStopX := -1;
  FIndent := 2;
  FTransparent := True;
  FCloseSpace := False;
  Color := clBlack;
  Font.Name := DEFFONTNAME;
  Font.Color := clWhite;
  Font.Size := DEFFONTSIZE;
  FDFColor := clWhite;
end;

destructor TDEdit.Destroy;
begin
  inherited;
end;

procedure TDEdit.DirectPaint(dsurface: TDXDrawCanvas);
var
  dc,  fDc: TRect;
  nLeft: integer;
  
  ShowStr: string;
  StopX, StartX, CaretIdx: Integer;
  boLeft: byte;
begin
  
  dc.Left := SurfaceX(Left);
  dc.Top := SurfaceY(Top);
  dc.Right := SurfaceX(left + Width);
  dc.Bottom := SurfaceY(top + Height);

  if not FTransparent then begin
    g_DXCanvas.FillRect(dc.Left, dc.Top, Width, Height, $FF000000 or LongWord(Color));
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, FrameColor);
  end;

  if (GetTickCount - FCaretShowTime) > 500 then begin 
    FCaretShowTime := GetTickCount;
    FCaretShow := not FCaretShow;
  end;
  nLeft := 0;
  boLeft := 0;
  with {g_DXCanvas}dsurface do begin
    if FEditString <> '' then begin
      if (FStartX <> FStopX) and (FStopX >= 0) and (FStartX >= 0) then begin
        StopX := FStopX;
        StartX := FStartX;
        CaretIdx := FCaretStart;
        if Height < 14 then begin
          dc.Top := SurfaceY(Top);
          dc.Bottom := SurfaceY(top + Height);
        end else begin
          dc.Top := SurfaceY(Top + (Height - 14) div 2);
          dc.Bottom := SurfaceY(top + Height - (Height - 14) div 2);
        end;
        if StartX > StopX then begin
          StartX := FStopX;
          StopX := FStartX;
          boLeft := 1;
        end;
        if StartX < CaretIdx then begin
          dc.Left := SurfaceX(Left + FIndent);
          ShowStr := Copy(FEditString, CaretIdx, StopX - CaretIdx);
          dc.Right := dc.Left + TextWidth(ShowStr);
          boLeft := 2;
        end else begin
          if FCaretStart > 0 then begin
            ShowStr := Copy(FEditString, CaretIdx, StartX - CaretIdx);
            dc.Left := SurfaceX(Left + FIndent) + TextWidth(ShowStr);
          end else begin
            ShowStr := Copy(FEditString, CaretIdx, StartX - CaretIdx);
            dc.Left := SurfaceX(Left + FIndent) + TextWidth(ShowStr);
          end;
          ShowStr := Copy(FEditString, StartX, StopX - StartX);
          dc.Right := dc.Left + TextWidth(ShowStr);
        end;
        dc.Right := _MIN(dc.Right, SurfaceX(Left + Width - FIndent * 2));
       // FillRect(dc, cColor4($C9C66931), fxBlend);
        FillRect(dc, cColor4($FFFF0000), fxBlend); //修改TDEIT输入复制背景颜色为蓝色

        fDc := dc;
      end;

      dc.Left := SurfaceX(Left + FIndent);
      dc.Top := SurfaceY(Top);
      dc.Right := SurfaceX(left + Width - FIndent * 2);
      dc.Bottom := SurfaceY(top + Height);
      if FCursor = deLeft then begin
        ShowStr := Copy(FEditString, FCaretStart, Length(FEditString));
        ShowStr := GetPasswordstr(ShowStr);
        TextRect(dc, ShowStr, FDFColor, [tfSingleLine, tfLeft, tfVerticalCenter]);
        nLeft := _MIN(TextWidth(Copy(FEditString, FCaretStart, FCaretPos - FCaretStart)), Width - FIndent * 2);
        if FDFColor <> clWhite then begin
          ShowStr := GetPasswordstr(GetCopy);
          if ShowStr <> '' then begin
            if boLeft = 1 then
              TextRect(Fdc, ShowStr, clWhite, [tfSingleLine, tfleft, tfVerticalCenter])
            else
              TextRect(Fdc, ShowStr, clWhite, [tfSingleLine, tfRight, tfVerticalCenter]);
          end;
        end;
      end else begin
        ShowStr := copy(FEditString, 1, FCaretStop - 1);
        ShowStr := GetPasswordstr(ShowStr);
        TextRect(dc, ShowStr, FDFColor, [tfSingleLine, tfRight, tfVerticalCenter]);
        ShowStr := Copy(FEditString, FCaretPos, FCaretStop - FCaretPos);
        nLeft := _MIN(Width - FIndent * 3 - TextWidth(ShowStr), Width - FIndent * 3);
        if FDFColor <> clWhite then begin
          ShowStr := GetPasswordstr(GetCopy);
          if ShowStr <> '' then begin
            TextRect(Fdc, ShowStr, clWhite, [tfSingleLine, tfLeft, tfVerticalCenter]);
          end;
        end;
      end;
    end;
    
    if FCaretShow and (KeyControl = Self) then begin
      FrmIMEX := SurfaceX(nLeft + FIndent + left);
      if Height < 16 then begin
        RoundRect(SurfaceX(nLeft + FIndent + left), SurfaceY(Top),
          SurfaceX(left + FIndent + 1 + nLeft), SurfaceY(top + Height), FTimeShowColor{clWhite});
        FrmIMEY := SurfaceY(Top);
      end else begin
        RoundRect(SurfaceX(nLeft + FIndent + left), SurfaceY(Top + 1),
          SurfaceX(left + FIndent + 1 + nLeft), SurfaceY(top + (Height - 2)), FTimeShowColor{clWhite});
        FrmIMEY := SurfaceY(Top + 1);
      end;
    end;
  end;
   if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

procedure TDEdit.Enter;
begin
 // CloseIME;
  inherited;
end;

function TDEdit.GetCopy: string;
begin
  Result := '';
  if FStartX > FStopX then begin
    Result := Copy(FEditString, FStopX, FStartX - FStopX);
  end
  else begin
    Result := Copy(FEditString, FStartX, FStopX - FStartX);
  end;
end;

function TDEdit.GetPasswordstr(str: string): string;
var
  i: Integer;
begin
  Result := str;
  if str = '' then
    Exit;
  if PasswordChar <> #0 then begin
    Result := '';
    for I := 1 to Length(str) do
      Result := Result + PasswordChar;
  end;
end;

function TDEdit.GetText: string;
begin
  Result := string(FEditString);
end;

function TDEdit.GetValue: Integer;
begin
  Result := StrToIntDef(string(FEditString), 0);
end;

function TDEdit.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
var
  i: integer;
  Clipboard: TClipboard;
  AddTx: string;
  nKey: Char;
  boChange: Boolean;
begin
  Result := FALSE;

  if (KeyControl = self) then begin
    KeyDownControl := Self;
    if Assigned(FOnKeyDown) then
     FOnKeyDown(self, Key, Shift);
    if Key = 0 then
      exit;
    if (ssCtrl in Shift) and (not Downed) and (Key = Word('X')) then begin
      if (FPasswordChar = #0) then begin
        if (FStartX > -1) and (FStopX > -1) and (FStartX <> FStopX) then begin
          Clipboard := TClipboard.Create;

          Clipboard.AsText := GetCopy;
          Clipboard.Free;
          ClearKey();
          TextChange();
        end;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('C')) then begin
      if (FPasswordChar = #0) then begin
        if (FStartX > -1) and (FStopX > -1) and (FStartX <> FStopX) then begin
          Clipboard := TClipboard.Create;
          Clipboard.AsText := GetCopy;
          Clipboard.Free;
        end;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('V')) then begin
      if (FPasswordChar = #0) or (FPasswordChar = '*') then begin
        ClearKey();
        Clipboard := TClipboard.Create;
        AddTx := Clipboard.AsText;
        for I := 1 to Length(AddTx) do begin
          nKey := AddTx[i];
          if (nKey = #13) or (nKey = #10) then
            Continue;
          KeyPress(nKey);
        end;

        Clipboard.Free;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('A')) then begin
      SetFocus;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssShift in Shift) and (not Downed) then begin
      KeyDowned := True;

      if FStartX < 0 then
        FStartX := FCaretPos;
    end
    else
      KeyDowned := False;
    case Key of
      VK_RIGHT: begin
          if not Downed then
            SetCursorPos(deRight);
          if (ssShift in Shift) then begin
            FCursor := deLeft;
            FStopX := FCaretPos
          end
          else begin
            FStartX := -1;
            FStopX := -1;
            KeyDowned := False;
          end;
          Key := 0;
          Result := TRUE;
        end;
      VK_LEFT: begin
          if not Downed then
            SetCursorPos(deLeft);
          if (ssShift in Shift) then begin
            FCursor := deLeft;
            FStopX := FCaretPos
          end
          else begin
            FStartX := -1;
            FStopX := -1;
            KeyDowned := False;
          end;
          Key := 0;
          Result := TRUE;
        end;
      VK_DELETE: begin
          boChange := ClearKey;
          if (not FReadOnly) and (not Downed) and (not KeyDowned) and (not
            boChange) then begin
            Delete(FEditString, FCaretPos, 1);
            FCaretPos := _Min(FCaretPos, Length(FEditString) + 1);
            FCursor := deLeft;
            TextChange();
          end
          else if boChange then
            TextChange();
          Key := 0;
          Result := TRUE;
        end;
    end;
    
    
  end;
end;

function TDEdit.KeyPress(var Key: Char): Boolean;
var
  boChange: Boolean;
begin
  Result := False;

  if (KeyControl = Self)then begin
    Result := TRUE;
    if (not Downed) and (not FReadOnly) then begin

      if Assigned(FOnKeyPress) then
        FOnKeyPress(self, Key);
      if Key = #0 then  Exit;

      case Key of
        Char(VK_BACK): begin
            boChange := ClearKey;
            if (FEditString <> '') and (not boChange) then begin
              FCursor := deleft;
              Delete(FEditString, FCaretPos - 1, 1);
              SetCursorPos(deLeft);
              TextChange();
            end
            else if boChange then
              TextChange();
          end;
      else begin
          
          if (FEditClass = deInteger) and (not (key in AllowedIntegerChars)) then begin
            Key := #0;
            exit;
          end
          else if ((FEditClass = deMonoCase) or (FPasswordChar <> #0)) and (not (key in AllowedEnglishChars)) then begin
            Key := #0;
            exit;
          end;
          if (FEditClass = deEnglishAndInt) and (not (key in AllowedStandard)) then begin
            key := #0;
            exit;
          end;
          if (FEditClass = deCDKey) and (not (key in AllowedCDKey)) then begin
            key := #0;
            exit;
          end;
          if (key in AllowedChars) then begin
            if IsDBCSLeadByte(Ord(Key)) or bDoubleByte then begin
              bDoubleByte := true;
              Inc(KeyByteCount);
              FInputStr := FInputStr + key;
            end;
            if not bDoubleByte then begin
              if FCloseSpace and (Key = #32) then begin
                Key := #0;
                exit;
              end;
              if (FEditClass = deStandard) and (not (key in AllowedStandard)) then begin
                Key := #0;
                exit;
              end;

              ClearKey;
              if (MaxLength > 0) and (Length(string(FEditString)) >= MaxLength) then begin
                Key := #0;
                exit;
              end;
              if FCaretPos <= Length(FEditString) then begin
                Insert(Key, FEditString, FCaretPos);
                SetCursorPosEx(1);
              end
              else begin
                FEditString := FEditString + Key;
                SetCursorPos(deRight);
              end;
              Key := #0;
              TextChange();
            end
            else if KeyByteCount >= 2 then begin
              if length(FInputStr) <> 2 then begin
                bDoubleByte := false;
                KeyByteCount := 0;
                FInputStr := '';
                Key := #0;
                exit;
              end;
              if (FEditClass = deStandard) and (not FiltrateStandardChar(Ord(FInputStr[1]), Ord(FInputStr[2]))) then begin
                bDoubleByte := false;
                KeyByteCount := 0;
                FInputStr := '';
                Key := #0;
                exit;
              end;
              if (FEditClass = deChinese) and (not FiltrateChar(Ord(FInputStr[1]), Ord(FInputStr[2]))) then begin
                bDoubleByte := false;
                KeyByteCount := 0;
                FInputStr := '';
                Key := #0;
                exit;
              end;
              ClearKey;
              if (MaxLength > 0) and (Length(string(FEditString)) >= (MaxLength - 1)) then begin
                bDoubleByte := false;
                KeyByteCount := 0;
                FInputStr := '';
                Key := #0;
                exit;
              end;
              if FCaretPos <= Length(FEditString) then begin
                Insert(FInputStr, FEditString, FCaretPos);
                SetCursorPosEx(1);
              end
              else begin
                FEditString := FEditString + FInputStr;
                SetCursorPos(deRight);
              end;
              TextChange();
              bDoubleByte := false;
              KeyByteCount := 0;
              FInputStr := '';
              Key := #0;
            end;
          end;
        end;
      end;
    end;
    Key := #0;
  end;
end;

function TDEdit.KeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;
  if (KeyControl = self) then begin
    //CloseIME;
    if (Key = VK_SHIFT) then begin
      KeyDowned := False;
      if FStopX = -1 then
        FStartX := -1;
    end;
    if Assigned(FOnKeyUp) then
      FOnKeyUp(self, Key, Shift);
    Key := 0;
    Result := TRUE;
  end;
end;

procedure TDEdit.Leave;
begin
  FStartX := -1;
  FStopX := -1;
  inherited;
end;

function TDEdit.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  {if Self Is TDComboBox then begin
    Result := inherited MouseDown(Button, Shift, X, Y);
    exit;
  end;  }
  Result := FALSE;
  if inherited MouseDown(Button, Shift, X, Y) then begin
    if (not Background) and (MouseCaptureControl = nil) then begin
      KeyDowned := False;
      if mbLeft = Button then begin
        FStartX := -1;
        FStopX := -1;
        if (FocusedControl = self) then begin
          MoveCaret(X - left, Y - top);
        end;
        if  TranFrame=False then  //2017.6.16 修正UI编辑器开发者模式不执行鼠标事件
        Downed := True;
      end;
      SetDCapture(self);
    end;
    Result := TRUE;
  end;
end;

function TDEdit.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
begin
  {if Self Is TDComboBox then begin
    Result := inherited MouseMove(Shift, X, Y);
    exit;
  end;     }
  Result := inherited MouseMove(Shift, X, Y);
  Moveed := Result;
  if Result and (MouseCaptureControl = self) then begin
    if Downed and (not KeyDowned) then
      MoveCaret(X - left, Y - top);
  end;
end;

function TDEdit.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  Downed := False;
  {if Self Is TDComboBox then begin
    Result := inherited MouseUp(Button, Shift, X, Y);
    exit;
  end;  }
  if inherited MouseUp(Button, Shift, X, Y) then begin
    ReleaseDCapture;
    if not Background then begin
      if InRange(X, Y) then begin
        if Assigned(FOnClick) then
          FOnClick(self, X, Y);
      end;
    end;
    Result := TRUE;
    exit;
  end
  else begin
    ReleaseDCapture;
  end;
end;

procedure TDEdit.MoveCaret(X, Y: Integer);
var
  i: Integer;
  temstr: WideString;
begin
  FCursor := deLeft;
  if Length(FEditString) > 0 then begin
    if (X <= g_DXCanvas.TextWidth('A')) and (FCaretStart > 1) then
      Dec(FCaretStart);
    for i := FCaretStart to Length(FEditString) do begin
      temstr := Copy(FEditString, FCaretStart, I - FCaretStart + 1);

      if g_DXCanvas.TextWidth(temstr) > X then begin
        while I <> FCaretPos do begin
          if I > FCaretPos then begin
            SetCursorPos(deRight)
          end
          else begin
            SetCursorPos(deLeft);
          end;
        end;
        if Downed or KeyDowned then
          FStopX := FCaretPos
        else
          FStartX := FCaretPos;
        exit;
      end;
    end;
    while (Length(FEditString) + 1) <> FCaretPos do begin
      if (Length(FEditString) + 1) > FCaretPos then begin
        SetCursorPos(deRight)
      end
      else begin
        SetCursorPos(deLeft);
      end;
    end;
    if Downed or KeyDowned then
      FStopX := FCaretPos
    else
      FStartX := FCaretPos;
  end;
end;

function TDEdit.Selected: Boolean;
begin
  Result := False;
  if (FStartX > -1) and (FStopX > -1) and (FStartX <> FStopX) then
    Result := True;

end;

procedure TDEdit.SetCursorPos(cCursor: TCursor);
var
  tempstr: WideString;
begin
  if cCursor = deRight then begin
    Inc(FCaretPos);
    if FCaretPos > (Length(FEditString) + 1) then
      FCaretPos := (Length(FEditString) + 1);
    while True do begin
      tempstr := Copy(FEditString, FCaretStart, FCaretPos - FCaretStart);
      if (FCaretStart < FCaretPos) and (g_DXCanvas.TextWidth(tempstr) > (Width - FIndent * 2)) then begin
        FCursor := deRight;
        Inc(FCaretStart);
        FCaretStop := FCaretPos;
      end
      else if FCaretPos > FCaretStop then begin
        FCaretStop := FCaretPos;
      end
      else
        Break;
    end;
  end
  else begin
    if FCaretPos > 1 then
      Dec(FCaretPos);
    if (FCaretPos <= FCaretStart) and (FCaretStart > 1) then begin
      FCursor := deleft;
      Dec(FCaretStart);
      FCaretStop := FCaretPos;
    end;
  end;
end;

procedure TDEdit.SetCursorPosEx(nLen: Integer);
var
  tempstr: WideString;
begin
  FCursor := deLeft;
  Inc(FCaretPos, nLen);
  if FCaretPos > (Length(FEditString) + 1) then
    FCaretPos := (Length(FEditString) + 1);
  while True do begin
    tempstr := Copy(FEditString, FCaretStart, FCaretPos - FCaretStart);
    if (FCaretStart < FCaretPos) and (g_DXCanvas.TextWidth(tempstr) > (Width - FIndent * 2)) then begin
      FCursor := deRight;
      Inc(FCaretStart);
      FCaretStop := FCaretPos;
    end
    else if FCaretPos > FCaretStop then begin
      FCaretStop := FCaretPos;
    end
    else
      Break;
  end;
end;

procedure TDEdit.SetFocus;
begin
  inherited;
  if FEditString <> '' then begin
    FStartX := 1;
    FStopX := Length(FEditString) + 1;
  end;
end;

procedure TDEdit.SetText(Value:string);
var
  i: Integer;
  nKey: Char;
  OldKeyControl: TDControl;
  OldFOnChange: TOnClick;
  OldReadOnly: Boolean;
begin
  FEditString := '';
  FCursor := deLeft;
  FCaretStart := 1;
  FCaretStop := 1;
  FCaretPos := 1;
  FStartX := -1;
  OldKeyControl := KeyControl;
  KeyControl := Self;
  OldFOnChange := FOnChange;
  FOnChange := nil;
  OldReadOnly := ReadOnly;
  ReadOnly := False;
  try
    for I := 1 to Length(Value) do begin
      nKey := Value[i];
      KeyPress(nKey);
    end;
  finally
    KeyControl := OldKeyControl;
    FOnChange := OldFOnChange;
    ReadOnly := OldReadOnly;
  end;
end;

procedure TDEdit.SetValue(const Value: Integer);
begin
  SetText(IntToStr(Value));
end;

procedure TDEdit.TextChange;
begin
  if Assigned(FOnChange) then
    FOnChange(self);
end;



constructor TDComboBox.Create(AOwner: TComponent);
begin
  inherited;

  
  FUpDown := TDUpDown.Create(nil);
  SetUpDownButton(FUpDown);
  FItem := TStringList.Create;
  ReadOnly := True;
  FShowCount := 5;
  FShowHeight := 18;
  FListIndex := 0;
  FDWidth := 0;
  FImageWidth := 0;
  FItemIndex := -1;
  FOnChange := nil;
  DFColor := $DEDBDE;
end;

destructor TDComboBox.Destroy;
begin
  FItem.Free;
  FUpDown.Free;
  inherited;
end;

procedure TDComboBox.DirectPaint(dsurface: TDXDrawCanvas);
var
  dc: TRect;
  d: TDXTexture;
  ShowStr: string;
  nI: Integer;
  I: Integer;
  nShowCount: Integer;
begin
  if Assigned(FOnDirectPaint) then
    FOnDirectPaint(self, dsurface)
  else begin

    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);

    if not FTransparent then begin
      g_DXCanvas.FillRect(dc.Left, dc.Top, Width, Height, $FF000000 or LongWord(Color));
      g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, FrameColor);
    end;
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(dc.Right - d.Width, dc.Top + (Height - d.Height) div 2, d.ClientRect, d, True);
      end;
    end;
    if (GetTickCount - FCaretShowTime) > 500 then begin
      FCaretShowTime := GetTickCount;
      FCaretShow := not FCaretShow;
    end;
    with g_DXCanvas do begin
      if FItemIndex >= FItem.Count then
        FItemIndex := -1;
      if FItemIndex > -1 then begin
        dc.Left := SurfaceX(Left + FIndent);
        dc.Top := SurfaceY(Top);
        dc.Right := SurfaceX(left + Width - FIndent * 2 - FImageWidth);
        dc.Bottom := SurfaceY(top + Height);
        ShowStr := FItem.Strings[FItemIndex];
        TextRect(dc, ShowStr, DFColor, [tfSingleLine, tfLeft, tfVerticalCenter]);
      end;
      dc.Left := SurfaceX(Left);
      dc.Top := SurfaceY(Top);
      dc.Right := SurfaceX(left + Width);
      dc.Bottom := SurfaceY(top + Height);
      if (FocusedControl = self) then begin
        FillRect(SurfaceX(Left), SurfaceY(top + Height), Width, MAX(10, FListHeight), $A0000000);
        nShowCount := MIN(FShowCount, FItem.Count);
        FListHeight := nShowCount * FShowHeight;
        if FUpDown.Visible then begin
          FDWidth := Width - FUpDown.Width;
        end
        else
          FDWidth := Width;
        RoundRect(SurfaceX(Left),
          SurfaceY(top + Height),
          SurfaceX(left + Width),
          SurfaceY(top + Height + MAX(10, FListHeight)), $FF737D73);

        FUpDown.Height := FListHeight - 2;
        FUpDown.Top := Height + 1;
        FUpDown.Left := Width - FUpDown.Width;

        
        dc.Left := SurfaceX(Left) + 2;
        dc.Right := dc.Left + FDWidth - 3;
        dc.Top := SurfaceY(top + Height) + 2;
        dc.Bottom := dc.Top + FShowHeight - 5;

        nI := 0;
        for I := FUpDown.Position to (FUpDown.Position + nShowCount - 1) do begin
          if I >= FItem.Count then begin
            FUpDown.Position := 0;
            break;
          end;
          ShowStr := FItem[i];
          if (SurfaceX(FX) >= dc.Left) and (SurfaceX(FX) < dc.Right) and
            (SurfaceY(FY) >= dc.Top) and (SurfaceY(FY) < dc.Bottom) then begin
            FillRect(dc.Left, dc.Top, dc.Right - dc.Left, dc.Bottom - dc.Top, $A062625A);
          end;
          TextRect(dc, ShowStr, DFColor, [tfSingleLine, tfLeft, tfVerticalCenter]);
          
          dc.Top := SurfaceY(top + Height) + 1 + FShowHeight * (nI + 1);
          dc.Bottom := dc.Top + FShowHeight - 2;
          Inc(nI);
        end;
      end
      else
        FUpDown.Visible := False;
    end;
    if FUpDown.Visible then
      FUpDown.DirectPaint(dsurface);
  end;
    if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

function TDComboBox.GetItemIndex: Integer;
begin
  if FItemIndex >= FItem.Count then
    FItemIndex := -1;
  Result := FItemIndex;
end;

function TDComboBox.InRange(x, y: integer): Boolean;
var
  boinrange: Boolean;

begin
  if  ((x >= Left) and (x < Left + Width) and (y >= Top) and (y < Top + Height)) or
    ((FocusedControl = self) and (x >= Left) and (x < Left + FDWidth) and (y >= Top) and
      (y < Top + Height + FListHeight))
  then begin
    boinrange := TRUE;
    if Assigned(FOnInRealArea) then
      FOnInRealArea(self, x - Left, y - Top, boinrange);
    
    Result := boinrange;
  end
  else
    Result := FALSE;
end;

function TDComboBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
var
  i: Integer;
begin
  Result := inherited MouseDown(Button, Shift, X, Y);
  if Result and (FocusedControl = self) then begin
    if InRange(x, y) and (Y > Top + height) then begin
      i := (Y - Top - Height) div FShowHeight + FUpDown.Position;
      if (I < FItem.Count) and (I >= 0) and (FItemIndex <> I) then begin
        FItemIndex := I;
        if Assigned(FOnChange) then
          FOnChange(Self);
      end;
      
      FocusedControl := nil;
      FUpDown.Visible := False;
    end
    else begin
      if FItem.Count > FShowCount then begin
        FUpDown.MaxPosition := FItem.Count - FShowCount;
        if FUpDown.Position > (FItem.Count - FShowCount) then
          FUpDown.Position := 0;

        FUpDown.Visible := True;
      end;
    end;
  end;
end;

function TDComboBox.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := inherited MouseMove(Shift, X, Y);
  if Result and (FocusedControl = self) then begin
    FX := X;
    FY := Y;
  end;
end;

function TDComboBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := inherited MouseUp(Button, Shift, X, Y);
end;

procedure TDComboBox.SetItem(const Value: TStrings);
begin
  if Assigned(FItem) then
    FItem.Assign(Value)
  else
    FItem := Value;
  if FItem.Count > FShowCount then begin
    FUpDown.MaxPosition := FItem.Count - FShowCount;
    if FUpDown.Position > (FItem.Count - FShowCount) then
      FUpDown.Position := 0;
  end
  else
    FUpDown.Visible := False;
end;

procedure TDComboBox.SetItemIndex(const Value: Integer);
begin
  if Value >= FItem.Count then
    FItemIndex := -1
  else
    FItemIndex := Value;
end;

procedure TDComboBox.SetShowCount(Value: Integer);
begin
  FShowCount := Value;
  FListHeight := FShowCount * FShowHeight;
end;

procedure TDComboBox.SetShowHeight(Value: Integer);
begin
  FShowHeight := Value;
  FListHeight := FShowCount * FShowHeight;
end;

procedure TDComboBox.SetUpDownButton(Button: TDUpDown);
begin
  Button.DParent := Self;
  Button.Visible := False;
  Button.Offset := 0;
  Button.MoveShow := True;
  Button.FMouseFocus := False;
  Button.UpButton.FMouseFocus := False;
  Button.DownButton.FMouseFocus := False;
  Button.MoveButton.FMouseFocus := False;
  AddChild(Button);
end;

//
//
//procedure TDListView.AddHead(sName: string; DBiDiMode: TDBiDiMode; Width: Word);
//var
//  DListViewHead: pTDListViewHead;
//begin
//  if (sName <> '') then begin
//    New(DListViewHead);
//    DListViewHead.sName := sName;
//    DListViewHead.DBiDiMode := DBiDiMode;
//    DListViewHead.nWidth := Width;
//    FHeadList.Add(DListViewHead);
//  end;
//end;
//
//function TDListView.AddItem: TStringList;
//var
//  StringList: TStringList;
//begin
//  StringList := TStringList.Create;
//  FItemList.Add(StringList);
//  Result := StringList;
//end;
//
//procedure TDListView.Clear;
//var
//  StringList: TStringList;
//  I: Integer;
//begin
//  for I := 0 to FItemList.Count - 1 do begin
//    StringList := FItemList.Items[i];
//    StringList.Free;
//  end;
//  FItemList.Clear;
//  FUpDown.Position := 0;
//end;
//
//procedure TDListView.ClearHead;
//var
//  DListViewHead: pTDListViewHead;
//  I: Integer;
//begin
//  for I := 0 to FHeadList.Count - 1 do begin
//    DListViewHead := FHeadList.Items[i];
//    Dispose(DListViewHead);
//  end;
//  FHeadList.Clear;
//end;
//
//constructor TDListView.Create(AOwner: TComponent);
//begin
//  inherited;
//  FUpDown := TDUpDown.Create(nil);
//  SetUpDownButton(FUpDown);
//  FHeadList := TList.Create;
//  FItemList := TList.Create;
//  Color := $004A8494;
//  FItemHeigth := 18;
//  FItemIndex := -1;
//  FOnItemIndex := nil;
//end;
//
//destructor TDListView.Destroy;
//begin
//  Clear;
//  ClearHead;
//  FHeadList.Free;
//  FUpDown.Free;
//  FItemList.Free;
//  inherited;
//end;
//
//procedure TDListView.DirectPaint(dsurface: TDXDrawCanvas);
//var
//dc :TRect;
//begin
//
//  if FItemList.Count > FItemCount then begin
//    FUpDown.Top := FItemHeigth + 1;
//    FUpDown.Left := Width - FUpDown.Width - 1;
//    FUpDown.Height := Height - FItemHeigth - 2;
//    FUpDown.DirectPaint(dsurface);
//  end
//  else
//    FUpDown.Position := 0;
//   if  TranFrame then begin
//    dc.Left := SurfaceX(Left);
//    dc.Top := SurfaceY(Top);
//    dc.Right := SurfaceX(left + Width);
//    dc.Bottom := SurfaceY(top + Height);
//    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
//  end;
//end;
//
//function TDListView.GetItems(Index: Integer): TStringList;
//begin
//  Result := nil;
//  if (Index >= 0) and (Index < FItemList.Count) then
//    Result := FItemList.Items[Index];
//end;
//
//function TDListView.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
//  Y: Integer): Boolean;
//var
//  i: Integer;
//  DListViewHead: pTDListViewHead;
//begin
//  Result := inherited MouseDown(Button, Shift, X, Y);
//  if Result and (FocusedControl = self) and ((X - left) < (Width -
//    FUpDown.Width)) and
//    (FItemIndex <> -1) then begin
//    Dec(x, left);
//    for I := 0 to FHeadList.Count - 1 do begin
//      DListViewHead := FHeadList.Items[i];
//      if X < DListViewHead.nWidth then begin
//        if Assigned(FOnItemIndex) then
//          FOnItemIndex(Self, FItemIndex, I);
//        Break;
//      end;
//      Dec(X, DListViewHead.nWidth);
//    end;
//  end;
//end;
//
//function TDListView.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
//begin
//  Result := inherited MouseMove(Shift, X, Y);
//  if Result and (InRange(x, y)) then begin
//    if (Y - top) <= FItemHeigth then begin
//      FItemIndex := -1;
//    end
//    else
//      FItemIndex := ((Y - top) - FItemHeigth) div FItemHeigth +
//        FUpDown.Position;
//    if (FItemIndex - FUpDown.Position) > (FItemCount - 1) then
//      FItemIndex := -1;
//
//  end;
//end;
//
//procedure TDListView.SetUpDownButton(Button: TDUpDown);
//begin
//  Button.DParent := Self;
//  Button.Visible := True;
//
//  AddChild(Button);
//end;



function TDMemo.ClearKey: Boolean;
var
  nStartY, nStopY: Integer;
  nStartX, nStopX: Integer;
  TempStr: WideString;
  i: Integer;
begin
  Result := False;
  if FLines.Count > 0 then begin
    if (FCaretX <> FSCaretX) or (FSCaretY <> FCaretY) then begin

      if FSCaretY < 0 then
        FSCaretY := 0;
      if FSCaretY >= FLines.Count then
        FSCaretY := FLines.Count - 1;

      if FCaretY < 0 then
        FCaretY := 0;
      if FCaretY >= FLines.Count then
        FCaretY := FLines.Count - 1;

      if FSCaretY = FCaretY then begin
        if FSCaretX > FCaretX then begin
          nStartX := FCaretX;
          nStopX := FSCaretX;
        end
        else begin
          nStartX := FSCaretX;
          nStopX := FCaretX;
        end;

        TempStr := TDMemoStringList(FLines).Str[FCaretY];
        Delete(TempStr, nStartX + 1, nStopX - nStartX);
        TDMemoStringList(FLines).Str[FCaretY] := TempStr;
        RefListWidth(FCaretY, 0);
        FCaretX := nStartX;
        SetCaret(True);
        Result := True;
      end
      else begin
        if FSCaretY > FCaretY then begin
          nStartY := FCaretY;
          nStopY := FSCaretY;
          nStartX := FCaretX;
          nStopX := FSCaretX;
        end
        else begin
          nStartY := FSCaretY;
          nStopY := FCaretY;
          nStartX := FSCaretX;
          nStopX := FCaretX;
        end;
        TempStr := TDMemoStringList(FLines).Str[nStartY];
        Delete(TempStr, nStartX + 1, 255);
        TDMemoStringList(FLines).Str[nStartY] := TempStr;

        TempStr := TDMemoStringList(FLines).Str[nStopY];
        Delete(TempStr, 1, nStopX);
        TDMemoStringList(FLines).Str[nStartY] :=
          TDMemoStringList(FLines).Str[nStartY] + TempStr;
        FLines.Objects[nStartY] := FLines.Objects[nStopY];
        FLines.Delete(nStopY);
        if (nStopY - nStartY) > 1 then
          for i := nStopY - 1 downto nStartY + 1 do
            FLines.Delete(i);
        RefListWidth(nStartY, nStartX);
        SetCaret(True);
        Result := True;
      end;
    end;
  end;
end;

constructor TDMemo.Create(AOwner: TComponent);
begin
  inherited;
  FKeyFocus := True;
  FCaretShowTime := GetTickCount;

  Downed := False;
  KeyDowned := False;

  FUpDown := nil;

  FTopIndex := 0;
  FCaretY := 0;
  FCaretX := 0;

  FSCaretX := 0;
  FSCaretY := 0;

  FInputStr := '';
  bDoubleByte := False;
  KeyByteCount := 0;

  FTransparent := False;

  FMaxLength := 0;

  FOnChange := nil;
  FReadOnly := False;
  FFrameColor := clBlack;
  Color := clBlack;

  FLines := TDMemoStringList.Create;
  TDMemoStringList(FLines).DMemo := Self;

  Font.Name := DEFFONTNAME;
  Font.Color := clWhite;
  Font.Size := DEFFONTSIZE;
  //g_DXCanvas.Font.Name := Font.Name;
  //g_DXCanvas.Font.Color := Font.Color;
  //g_DXCanvas.Font.Size := Font.Size;

  FMoveTick := GetTickCount;
end;

destructor TDMemo.Destroy;
begin
  FLines.Free;
  inherited;
end;

procedure TDMemo.DirectPaint(dsurface: TDXDrawCanvas);
var
  dc: TRect;
  nShowCount, i: Integer;
  ax, ay: Integer;
  TempStr: string;
  nStartY, nStopY: Integer;
  nStartX, nStopX: Integer;
  addax: Integer;
begin
  dc.Left := SurfaceX(Left);
  dc.Top := SurfaceY(Top);
  dc.Right := SurfaceX(left + Width);
  dc.Bottom := SurfaceY(top + Height);


  if not FTransparent then begin
    g_DXCanvas.FillRect(dc, cColor4(LongWord(Color) or $FF000000), fxBlend);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, FrameColor);
   { dsurface.Canvas.Brush.Color := Color;
    dsurface.Canvas.Pen.Color := FrameColor;
    dsurface.Canvas.Pen.Style := psAlternate;
    dsurface.Canvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, 0, 0);}
  end;
  if (GetTickCount - FCaretShowTime) > 500 then begin
    FCaretShowTime := GetTickCount;
    FCaretShow := not FCaretShow;
  end;

  nShowCount := (Height - 1) div 14;
  if (FTopIndex + nShowCount - 1) > Lines.Count then begin
    FTopIndex := Max(Lines.Count - nShowCount + 1, 0);
  end;
  if (FCaretY >= Lines.Count) then
    FCaretY := Max(Lines.Count - 1, 0);
  if FCaretY < 0 then begin
    FTopIndex := 0;
    FCaretY := 0;
  end;

  if Lines.Count > nShowCount then begin
    if FUpDown <> nil then begin
      if not FUpDown.Visible then
        FUpDown.Visible := True;
      FUpDown.MaxPosition := Lines.Count - nShowCount;
      FUpDown.Position := FTopIndex;
    end;
  end
  else begin
    if FUpDown <> nil then begin
      if FUpDown.Visible then
        FUpDown.Visible := False;
      FTopIndex := 0;
    end;
  end;

  if FSCaretY > FCaretY then begin
    nStartY := FCaretY;
    nStopY := FSCaretY;
    nStartX := FCaretX;
    nStopX := FSCaretX;
  end
  else begin
    nStartY := FSCaretY;
    nStopY := FCaretY;
    nStartX := FSCaretX;
    nStopX := FCaretX;
  end;
  if FSCaretY = FCaretY then begin
    if FSCaretX > FCaretX then begin
      nStartX := FCaretX;
      nStopX := FSCaretX;
    end
    else if FSCaretX < FCaretX then begin
      nStartX := FSCaretX;
      nStopX := FCaretX;
    end
    else begin
      nStartX := -1;
    end;
  end;
  ax := SurfaceX(Left) + 2;
  ay := SurfaceY(Top) + 2;
  with g_DXCanvas do begin
    //Font.Color := FDFColor;
    //SetBkMode(Handle, TRANSPARENT);
    for i := FTopIndex to (FTopIndex + nShowCount - 1) do begin
      if i >= Lines.Count then
        Break;
      if nStartY <> nStopY then begin
        if i = nStartY then begin
          TempStr := Copy(WideString(Lines[i]), 1, nStartX);
          TextOut(ax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
          addax := TextWidth(TempStr);
          //Release;
          TempStr := Copy(WideString(Lines[i]), nStartX + 1, 255);
          //SetBkMode(Handle, OPAQUE);
          //Brush.Color := $C66931;
          FillRect(ax + addax, ay + (i - FTopIndex) * 14 - 1, TextWidth(TempStr), 16, $C9C66931);
          TextOut(ax + addax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
          //Release;
          //SetBkMode(Handle, TRANSPARENT);
        end
        else if i = nStopY then begin
          //Release;
          TempStr := Copy(WideString(Lines[i]), 1, nStopX);
          addax := TextWidth(TempStr);
          //SetBkMode(Handle, OPAQUE);
          //Brush.Color := $C66931;
          FillRect(ax, ay + (i - FTopIndex) * 14 - 1, addax, 16, $C9C66931);
          TextOut(ax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
          //Release;
          //SetBkMode(Handle, TRANSPARENT);
          TempStr := Copy(WideString(Lines[i]), nStopX + 1, 255);
          TextOut(ax + addax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
        end
        else if (i > nStartY) and (i < nStopY) then begin
          //Release;
          //SetBkMode(Handle, OPAQUE);
          //Brush.Color := $C66931;
          FillRect(ax, ay + (i - FTopIndex) * 14 - 1, TextWidth(Lines[i]), 16, $C9C66931);
          TextOut(ax, ay + (i - FTopIndex) * 14, Lines[i], FDFColor);
          //Release;
          //SetBkMode(Handle, TRANSPARENT);
        end
        else
          TextOut(ax, ay + (i - FTopIndex) * 14, Lines[i], FDFColor);
      end
      else begin
        if (nStartX <> -1) and (i = FSCaretY) then begin
          TempStr := Copy(WideString(Lines[i]), 1, nStartX);
          TextOut(ax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
          addax := TextWidth(TempStr);
          //Release;
          TempStr := Copy(WideString(Lines[i]), nStartX + 1, nStopX - nStartX);
          //SetBkMode(Handle, OPAQUE);
          //Brush.Color := $C66931;
          FillRect(ax + addax, ay + (i - FTopIndex) * 14 - 1, TextWidth(TempStr), 16, $C9C66931);
          TextOut(ax + addax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
          addax := addax + TextWidth(TempStr);
          //Release;
          //SetBkMode(Handle, TRANSPARENT);
          TempStr := Copy(WideString(Lines[i]), nStopX + 1, 255);
          TextOut(ax + addax, ay + (i - FTopIndex) * 14, TempStr, FDFColor);
        end
        else
          TextOut(ax, ay + (i - FTopIndex) * 14, Lines[i], FDFColor);
      end;
    end;
    if (FCaretY >= FTopIndex) and (FCaretY < (FTopIndex + nShowCount)) then begin
      ay := ay + (Max(FCaretY - FTopIndex, 0)) * 14;
      if FCaretY < Lines.Count then begin
        TempStr := LeftStr(WideString(Lines[FCaretY]), FCaretX);
        ax := ax + TextWidth(TempStr);
      end;
      if FCaretShow and (KeyControl = Self) then begin
        //Pen.Color := Self.Font.Color;
        FrmIMEX := ax;
        FrmIMEY := ay;
        RoundRect(ax, ay, ax + 1, ay + 12, clWhite);
      end;
    end;
    //Release;
  end;        
  for i := 0 to DControls.Count - 1 do
    if TDControl(DControls[i]).Visible then
      TDControl(DControls[i]).DirectPaint(dsurface);
   if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

procedure TDMemo.Enter;
begin
  inherited;
end;

function TDMemo.GetKey: string;
var
  nStartY, nStopY: Integer;
  nStartX, nStopX: Integer;
  TempStr: WideString;
  i: Integer;
begin
  Result := '';
  if FLines.Count > 0 then begin
    if (FCaretX <> FSCaretX) or (FSCaretY <> FCaretY) then begin

      if FSCaretY < 0 then
        FSCaretY := 0;
      if FSCaretY >= FLines.Count then
        FSCaretY := FLines.Count - 1;

      if FCaretY < 0 then
        FCaretY := 0;
      if FCaretY >= FLines.Count then
        FCaretY := FLines.Count - 1;

      if FSCaretY = FCaretY then begin
        if FSCaretX > FCaretX then begin
          nStartX := FCaretX;
          nStopX := FSCaretX;
        end
        else begin
          nStartX := FSCaretX;
          nStopX := FCaretX;
        end;
        TempStr := FLines[FCaretY];
        Result := Copy(TempStr, nStartX + 1, nStopX - nStartX);
      end
      else begin
        if FSCaretY > FCaretY then begin
          nStartY := FCaretY;
          nStopY := FSCaretY;
          nStartX := FCaretX;
          nStopX := FSCaretX;
        end
        else begin
          nStartY := FSCaretY;
          nStopY := FCaretY;
          nStartX := FSCaretX;
          nStopX := FCaretX;
        end;
        TempStr := FLines[nStartY];
        Result := Copy(TempStr, nStartX + 1, 255);
        if Integer(FLines.Objects[nStartY]) = 13 then
          Result := Result + #13#10;
        if (nStopY - nStartY) > 1 then
          for i := nStartY + 1 to nStopY - 1 do begin
            Result := Result + FLines[i];
            if Integer(FLines.Objects[i]) = 13 then
              Result := Result + #13#10;
          end;
        TempStr := FLines[nStopY];
        Result := Result + Copy(TempStr, 1, nStopX);
        if Integer(FLines.Objects[nStopY]) = 13 then
          Result := Result + #13#10;
      end;
    end;
  end;
end;

function TDMemo.GetText: string;
var
  P: PChar;
begin
  P := FLines.GetText;
  Result := P;
  StrDispose(P);
end;

procedure TDMemo.IsVisible(flag: Boolean);
begin
  inherited;
  if FUpDown <> nil then begin
    FUpDown.Visible := flag;
  end;
end;

procedure TDMemo.KeyCaret(Key: Word);
var
  TempStr: WideString;
  nShowCount: Integer;
begin
  if FLines.Count > 0 then begin
    if FCaretY < 0 then
      FCaretY := 0;
    if FCaretY >= FLines.Count then
      FCaretY := FLines.Count - 1;
    TempStr := TDMemoStringList(FLines).Str[FCaretY];
    case Key of
      VK_UP: begin
          if FCaretY > 0 then
            Dec(FCaretY);
        end;
      VK_DOWN: begin
          if FCaretY < (FLines.Count - 1) then
            Inc(FCaretY);
        end;
      VK_RIGHT: begin
          if FCaretX < Length(TempStr) then
            Inc(FCaretX)
          else begin
            if FCaretY < (FLines.Count - 1) then begin
              Inc(FCaretY);
              FCaretX := 0;
            end;
          end;
        end;
      VK_LEFT: begin
          if FCaretX > 0 then
            Dec(FCaretX)
          else begin
            if FCaretY > 0 then begin
              Dec(FCaretY);
              FCaretX :=
                Length(WideString(TDMemoStringList(FLines).Str[FCaretY]));
            end;
          end;
        end;
    end;
    nShowCount := (Height - 1) div 14;
    if FCaretY < FTopIndex then
      FTopIndex := FCaretY
    else begin
      if (FCaretY - FTopIndex) >= nShowCount then begin
        FTopIndex := _Max(FCaretY - nShowCount + 1, 0);
      end;
    end;

    if not KeyDowned then
      SetCaret(False);
  end;
end;

function TDMemo.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
var
  Clipboard: TClipboard;
  AddTx, Data: string;
  boAdd: Boolean;
  TempStr: WideString;
  nKey: Char;
  I: Integer;
begin
  Result := FALSE;

  if (KeyControl = self) then begin
    if not FReadOnly then
      KeyDownControl := Self;
    if Assigned(FOnKeyDown) then
      FOnKeyDown(self, Key, Shift);
    if Key = 0 then
      exit;
    if (ssCtrl in Shift) and (not Downed) and (Key = Word('A')) then begin
      if FLines.Count > 0 then begin
        FCaretY := FLines.Count - 1;
        FCaretX := Length(WideString(TDMemoStringList(FLines).Str[FCaretY]));
        SetCaret(True);
        FSCaretX := 0;
        FSCaretY := 0;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('X')) then begin
      if not FReadOnly then begin
        AddTx := GetKey;
        if AddTx <> '' then begin
          Clipboard := TClipboard.Create;
          Clipboard.AsText := AddTx;
          Clipboard.Free;
          ClearKey();
          TextChange();
        end;
        Key := 0;
      end;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('C')) then begin
      AddTx := GetKey;
      if AddTx <> '' then begin
        Clipboard := TClipboard.Create;
        Clipboard.AsText := AddTx;
        Clipboard.Free;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssCtrl in Shift) and (not Downed) and (Key = Word('V')) then begin
      if not FReadOnly then begin
        ClearKey();
      
        Clipboard := TClipboard.Create;
        AddTx := Clipboard.AsText;
        boAdd := False;
        while True do begin
          if AddTx = '' then break;
          AddTx := GetValidStr3(AddTx, data, [#13]);
          if Data <> '' then begin
            data := AnsiReplaceText(data, #10, '');
            if (MaxLength > 0) and ((Length(GetText) + Length(data)) >= MaxLength) then begin
              for I := 1 to Length(data) do begin
                nKey := data[i];
                if (nKey = #13) or (nKey = #10) then Continue;
                KeyPress(nKey);
              end;
              break;
            end;

            if Data = '' then Data := #9;
            if FLines.Count <= 0 then begin
              FLines.AddObject(Data, TObject(13));
              FCaretY := 0;
              RefListWidth(FCaretY, -1);
            end
            else if boAdd then begin
              Inc(FCaretY);
              FLines.InsertObject(FCaretY, Data, TObject(13));
              FCaretX := 0;
              RefListWidth(FCaretY, -1);
            end
            else begin
              TempStr := TDMemoStringList(FLines).Str[FCaretY];
              Insert(Data, TempStr, FCaretX + 1);
              TDMemoStringList(FLines).Str[FCaretY] := TempStr;
              Inc(FCaretX, Length(WideString(Data)));
              FLines.Objects[FCaretY] := TObject(13);
              RefListWidth(FCaretY, FCaretX);
            end;

            boAdd := True;
          end;
        end;
        if boAdd then TextChange();
        Clipboard.Free;
      end;
      Key := 0;
      Result := True;
      Exit;
    end
    else if (ssShift in Shift) and (not Downed) then begin
      KeyDowned := True;
    end
    else
      KeyDowned := False;
    if FLines.Count <= 0 then
      exit;
    case Key of
      VK_UP,
        VK_DOWN,
        VK_RIGHT,
        VK_LEFT: begin
          KeyCaret(Key);
          Key := 0;
          Result := TRUE;
        end;
      VK_BACK: begin
          if (not FReadOnly) then begin
            if not ClearKey then begin
              while True do begin
                TempStr := TDMemoStringList(FLines).Str[FCaretY];
                if FCaretX > 0 then begin
                  Delete(TempStr, FCaretX, 1);
                  if TempStr = '' then begin
                    FLines.Delete(FCaretY);
                    if FCaretY > 0 then begin
                      Dec(FCaretY);
                      FCaretX :=
                        Length(WideString(TDMemoStringList(FLines).Str[FCaretY]));
                      SetCaret(True);
                    end
                    else begin
                      FCaretY := 0;
                      FCaretX := 0;
                      SetCaret(False);
                    end;
                    Exit;
                  end
                  else begin
                    TDMemoStringList(FLines).Str[FCaretY] := TempStr;
                    Dec(FCaretX);
                  end;
                  break;
                end
                else if FCaretX = 0 then begin
                  if FCaretY > 0 then begin
                    if Integer(FLines.Objects[FCaretY - 1]) = 13 then begin
                      FLines.Objects[FCaretY - 1] := nil;
                      Break;
                    end
                    else begin
                      FLines.Objects[FCaretY - 1] := FLines.Objects[FCaretY];
                      FCaretX :=
                        Length(WideString(TDMemoStringList(FLines).Str[FCaretY -
                        1]));
                      TDMemoStringList(FLines).Str[FCaretY - 1] :=
                        TDMemoStringList(FLines).Str[FCaretY - 1] +
                        TDMemoStringList(FLines).Str[FCaretY];
                      FLines.Delete(FCaretY);
                      Dec(FCaretY);
                    end;
                  end
                  else
                    Break;
                end
                else
                  Break;
              end;
              RefListWidth(FCaretY, FCaretX);
              SetCaret(True);
            end;
            TextChange();
          end;
          Key := 0;
          Result := TRUE;
        end;
      VK_DELETE: begin
          if (not FReadOnly) then begin
            if not ClearKey then begin
              while True do begin
                TempStr := TDMemoStringList(FLines).Str[FCaretY];
                if Length(TempStr) > FCaretX then begin
                  Delete(TempStr, FCaretX + 1, 1);
                  if TempStr = '' then begin
                    FLines.Delete(FCaretY);
                    if FCaretY > 0 then begin
                      Dec(FCaretY);
                      FCaretX :=
                        Length(WideString(TDMemoStringList(FLines).Str[FCaretY]));
                      SetCaret(True);
                    end
                    else begin
                      FCaretY := 0;
                      FCaretX := 0;
                      SetCaret(False);
                    end;
                    Exit;
                  end
                  else
                    TDMemoStringList(FLines).Str[FCaretY] := TempStr;
                  break;
                end
                else if Integer(FLines.Objects[FCaretY]) = 13 then begin
                  FLines.Objects[FCaretY] := nil;
                  break;
                end
                else begin
                  if (FCaretY + 1) < FLines.Count then begin
                    TDMemoStringList(FLines).Str[FCaretY] :=
                      TDMemoStringList(FLines).Str[FCaretY] +
                      TDMemoStringList(FLines).Str[FCaretY + 1];
                    FLines.Objects[FCaretY] := FLines.Objects[FCaretY + 1];
                    FLines.Delete(FCaretY + 1);
                  end
                  else
                    Break;
                end;
              end;
              RefListWidth(FCaretY, FCaretX);
              SetCaret(True);
            end;
            TextChange();
          end;
          Key := 0;
          Result := TRUE;
        end;
    end;
    
    
  end;
end;

function TDMemo.KeyPress(var Key: Char): Boolean;
var
  
  TempStr, Temp: WideString;
  OldObject: Integer;
begin
  Result := False;
  if (KeyControl = Self) then begin
    if (not Downed) and (not FReadOnly) then begin
      Result := True;
      if Assigned(FOnKeyPress) then
        FOnKeyPress(self, Key);
      if Key = #0 then
        Exit;

      if (FCaretY >= Lines.Count) then
        FCaretY := _Max(Lines.Count - 1, 0);
      if FCaretY < 0 then begin
        FTopIndex := 0;
        FCaretY := 0;
      end;
      if Key = #13 then begin
        if (MaxLength > 0) and (Length(GetText) >= MaxLength) then begin
          Key := #0;
          exit;
        end;
        if FLines.Count <= 0 then begin
          FLines.AddObject('', TObject(13));
          FLines.AddObject('', TObject(13));
          FCaretX := 0;
          FCaretY := 1;
          SetCaret(True);
        end
        else begin
          Temp := TDMemoStringList(FLines).Str[FCaretY];
          OldObject := Integer(FLines.Objects[FCaretY]);

          TempStr := Copy(Temp, 1, FCaretX);
          TDMemoStringList(FLines).Str[FCaretY] := TempStr;
          FLines.Objects[FCaretY] := TObject(13);

          TempStr := Copy(Temp, FCaretX + 1, 255);
          if TempStr <> '' then begin
            FLines.InsertObject(FCaretY + 1, TempStr, TObject(OldObject));
          end
          else begin
            FLines.InsertObject(FCaretY + 1, '', TObject(OldObject));
          end;
          RefListWidth(FCaretY + 1, 0);
          FCaretY := FCaretY + 1;
          FCaretX := 0;
          SetCaret(True);
        end;
        exit;
      end;

      if (FEditClass = deInteger) and (not (key in AllowedIntegerChars)) then begin
        Key := #0;
        exit;
      end
      else if (FEditClass = deMonoCase) and (not (key in AllowedEnglishChars)) then begin
        Key := #0;
        exit;
      end;
      if (FEditClass = deEnglishAndInt) and (not (key in AllowedStandard)) then begin
        key := #0;
        exit;
      end;
      if (FEditClass = deCDKey) and (not (key in AllowedCDKey)) then begin
        key := #0;
        exit;
      end;

      if (key in AllowedChars) then begin
        if IsDBCSLeadByte(Ord(Key)) or bDoubleByte then begin
          bDoubleByte := true;
          Inc(KeyByteCount);
          FInputStr := FInputStr + key;
        end;
        if not bDoubleByte then begin
          if (FEditClass = deStandard) and (not (key in AllowedStandard)) then begin
            Key := #0;
            exit;
          end;
          ClearKey;
          if (MaxLength > 0) and (Length(GetText) >= MaxLength) then begin
            Key := #0;
            exit;
          end;
          if FLines.Count <= 0 then begin
            FLines.AddObject(Key, nil);
            FCaretX := 1;
            FCaretY := 0;
          end
          else begin
            TempStr := TDMemoStringList(FLines).Str[FCaretY];
            Insert(Key, TempStr, FCaretX + 1);
            TDMemoStringList(FLines).Str[FCaretY] := TempStr;
            Inc(FCaretX);
            RefListWidth(FCaretY, FCaretX);
          end;
          SetCaret(True);
          Key := #0;
          TextChange();
        end
        else if KeyByteCount >= 2 then begin
          if length(FInputStr) <> 2 then begin
            bDoubleByte := false;
            KeyByteCount := 0;
            FInputStr := '';
            Key := #0;
            exit;
          end;
          if (FEditClass = deStandard) and (not FiltrateStandardChar(Ord(FInputStr[1]), Ord(FInputStr[2]))) then begin
            bDoubleByte := false;
            KeyByteCount := 0;
            FInputStr := '';
            Key := #0;
            exit;
          end;
          if (FEditClass = deChinese) and (not FiltrateChar(Ord(FInputStr[1]), Ord(FInputStr[2]))) then begin
            bDoubleByte := false;
            KeyByteCount := 0;
            FInputStr := '';
            Key := #0;
            exit;
          end;
          ClearKey;
          if (MaxLength > 0) and (Length(string(GetText)) >= (MaxLength - 1)) then begin
            bDoubleByte := false;
            KeyByteCount := 0;
            FInputStr := '';
            Key := #0;
            exit;
          end;
          if FLines.Count <= 0 then begin
            FLines.AddObject(FInputStr, nil);
            FCaretX := 1;
            FCaretY := 0;
          end
          else begin
            TempStr := TDMemoStringList(FLines).Str[FCaretY];
            Insert(FInputStr, TempStr, FCaretX + 1);
            TDMemoStringList(FLines).Str[FCaretY] := TempStr;
            Inc(FCaretX);
            RefListWidth(FCaretY, FCaretX);
          end;
          SetCaret(True);
          bDoubleByte := false;
          KeyByteCount := 0;
          FInputStr := '';
          Key := #0;
          TextChange();
        end;
      end;
      Key := #0;
    end else begin
      Result := False;
    end;
  end;
end;

function TDMemo.KeyUp(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := FALSE;

  if (KeyControl = self) then begin
    if (ssShift in Shift) then begin
      KeyDowned := False;
    end;
    if Assigned(FOnKeyUp) then
      FOnKeyUp(self, Key, Shift);
    Key := 0;
    Result := TRUE;
  end;
end;

procedure TDMemo.Leave;
begin
  inherited;
end;

function TDMemo.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseDown(Button, Shift, X, Y) then begin
    if (not Background) and (MouseCaptureControl = nil) then begin
      KeyDowned := False;
      if mbLeft = Button then begin
        if (FocusedControl = self) then begin
          DownCaret(X - left, Y - top);
        end;
        SetCaret(False);
      if  TranFrame=False then  //2017.6.16 修正UI编辑器开发者模式不执行鼠标事件
        Downed := True;
      end;
      SetDCapture(self);
    end;
    Result := TRUE;
  end;
end;

function TDMemo.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
begin
  Result := inherited MouseMove(Shift, X, Y);
  if Result and (MouseCaptureControl = self) then begin
    if Downed and (not KeyDowned) then
      MoveCaret(X - left, Y - top);
  end;
end;

function TDMemo.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  Downed := False;
  if inherited MouseUp(Button, Shift, X, Y) then begin
    ReleaseDCapture;
    if not Background then begin
      if InRange(X, Y) then begin
        if Assigned(FOnClick) then
          FOnClick(self, X, Y);
      end;
    end;
    Result := TRUE;
    exit;
  end
  else begin
    ReleaseDCapture;
  end;
end;

procedure TDMemo.MoveCaret(X, Y: Integer);
var
  tempstrw: WideString;
  nShowCount, i: Integer;
  tempstr: string;
begin
  nShowCount := (Height - 1) div 14;
  if Y < 0 then begin 
    if (GetTickCount - FMoveTick) < 50 then
      Exit;
    if FTopIndex > 0 then
      Dec(FTopIndex);
    FCaretY := FTopIndex;
  end
  else if Y > Height then begin 
    if (GetTickCount - FMoveTick) < 50 then
      Exit;
    Inc(FCaretY);
    if FCaretY >= FLines.Count then
      FCaretY := _Max(FLines.Count - 1, 0);
    FTopIndex := _Max(FCaretY - nShowCount + 1, 0);
  end
  else
    FCaretY := (y - 1) div 14 + FTopIndex;
  FMoveTick := GetTickCount;

  if FCaretY >= FLines.Count then
    FCaretY := _Max(FLines.Count - 1, 0);
  FCaretX := 0;
  if FCaretY < FLines.Count then begin
    tempstrw := TDMemoStringList(FLines).Str[FCaretY];
    if tempstrw <> '' then begin
      for i := 1 to Length(tempstrw) do begin
        tempstr := Copy(tempstrw, 1, i);
        if (g_DXCanvas.TextWidth(tempstr)) > (X) then
          exit;
        FCaretX := i;
      end;
    end;
  end;
end;

procedure TDMemo.PositionChange(Sender: TObject);
begin
  FTopIndex := FUpDown.Position;
end;

procedure TDMemo.RefListWidth(ItemIndex: Integer; nCaret: Integer);
var
  i, Fi, nIndex, nY: Integer;
  TempStr, AddStr: WideString;
begin
  TempStr := '';
  nIndex := 0;
  while True do begin
    if ItemIndex >= FLines.Count then
      Break;
    TempStr := TempStr + TDMemoStringList(FLines).Str[ItemIndex];
    nIndex := Integer(Lines.Objects[ItemIndex]);
    FLines.Delete(ItemIndex);
    if nIndex = 13 then
      Break;
  end;
  if TempStr <> '' then begin
    AddStr := '';
    Fi := 1;
    nY := ItemIndex;
    for i := 1 to Length(TempStr) + 1 do begin
      AddStr := Copy(TempStr, Fi, i - Fi + 1);
      if g_DXCanvas.TextWidth(AddStr) > (Width - 20) then begin
        AddStr := Copy(TempStr, Fi, i - Fi);
        Fi := i;
        FLines.InsertObject(ItemIndex, AddStr, nil);
        nIndex := ItemIndex;
        Inc(ItemIndex);
        nY := ItemIndex;
        AddStr := '';
      end;
      if i = nCaret then begin
        FCaretX := i - Fi + 1;
        FCaretY := nY;
        SetCaret(True);
      end;
    end;
    if AddStr <> '' then begin
      FLines.InsertObject(ItemIndex, AddStr, TObject(13));
      nIndex := ItemIndex;
    end
    else begin
      FLines.Objects[nIndex] := TObject(13);
    end;
    if nCaret = -1 then begin
      FCaretY := nIndex;
      FCaretX := Length(WideString(TDMemoStringList(FLines).Str[nIndex]));
      SetCaret(True);
    end;
    
  end;
  if FCaretY >= FLines.Count then begin
    FCaretY := _Max(FLines.Count - 1, 0);
    SetCaret(True);
  end;
end;

procedure TDMemo.DownCaret(X, Y: Integer);
var
  tempstrw: WideString;
  i: Integer;
  tempstr: string;
begin
  FCaretY := (y - 1) div 14 + FTopIndex;
  if FCaretY >= FLines.Count then
    FCaretY := _Max(FLines.Count - 1, 0);
  FCaretX := 0;
  if FCaretY < FLines.Count then begin
    tempstrw := TDMemoStringList(FLines).Str[FCaretY];
    if tempstrw <> '' then begin
      for i := 1 to Length(tempstrw) do begin
        tempstr := Copy(tempstrw, 1, i);
        if (g_DXCanvas.TextWidth(tempstr)) > (X) then
          exit;
        FCaretX := i;
      end;
    end;
  end;
end;

function TDMemo.Selected: Boolean;
begin
  Result := False;
  if FLines.Count > 0 then begin
    if (FCaretX <> FSCaretX) or (FSCaretY <> FCaretY) then begin
      Result := True;
    end;
  end;
end;

procedure TDMemo.SetCaret(boBottom: Boolean);
var
  nShowCount: Integer;
begin
  FSCaretX := FCaretX;
  FSCaretY := FCaretY;
  if boBottom then begin
    nShowCount := (Height - 1) div 14;
    if FCaretY < FTopIndex then
      FTopIndex := FCaretY
    else begin
      if (FCaretY - FTopIndex) >= nShowCount then begin
        FTopIndex := _Max(FCaretY - nShowCount + 1, 0);
      end;
    end;
  end;
end;

procedure TDMemo.SetCaretY(const Value: Integer);
begin
  FCaretY := Value;
  if FCaretY >= FLines.Count then
    FCaretY := _Max(FLines.Count - 1, 0);
  if FCaretY < 0 then
    FCaretY := 0;
  SetCaret(True);
end;

procedure TDMemo.SetFocus;
begin
  inherited;
end;

procedure TDMemo.SetUpDown(const Value: TDUpDown);
begin
  FUpDown := Value;
  FWheelDControl := Value;
  if FUpDown <> nil then begin
    FUpDown.OnPositionChange := PositionChange;
    FUpDown.Visible := False;
    FUpDown.MaxPosition := 0;
    FUpDown.Position := 0;
  end;
end;

procedure TDMemo.TextChange;
begin
  if Assigned(FOnChange) then
    FOnChange(self);
end;



function TDMemoStringList.Add(const S: string): Integer;
begin
  Result := AddObject(S, TObject(13));
  DMemo.RefListWidth(Result, -1);
end;

function TDMemoStringList.AddObject(const S: string; AObject: TObject): Integer;
var
  AddStr: string;
begin
  AddStr := AnsiReplaceText(S, #13, '');
  AddStr := AnsiReplaceText(AddStr, #10, '');
  if AddStr = '' then begin
    Result := inherited AddObject(#9, AObject);
  end
  else
    Result := inherited AddObject(AddStr, AObject);
end;

procedure TDMemoStringList.Assign(Source: TPersistent);
begin
  inherited Assign(Source);
  DMemo.FCaretY := 0;
  DMemo.FCaretX := 0;
  DMemo.SetCaret(False);
end;

procedure TDMemoStringList.Clear;
begin
  inherited;
  DMemo.FCaretY := 0;
  DMemo.FCaretX := 0;
  DMemo.SetCaret(False);
end;

function TDMemoStringList.Get(Index: Integer): string;
begin
  Result := inherited Get(Index);
  Result := AnsiReplaceText(Result, #9, '');
end;

procedure TDMemoStringList.InsertObject(Index: Integer; const S: string;
  AObject: TObject);
var
  AddStr: string;
begin
  AddStr := AnsiReplaceText(S, #13, '');
  AddStr := AnsiReplaceText(AddStr, #10, '');
  if AddStr = '' then begin
    inherited InsertObject(Index, #9, AObject);
  end
  else
    inherited InsertObject(Index, AddStr, AObject);
end;

function TDMemoStringList.GetText: PChar;
var
  i: Integer;
  AddStr: string;
begin
  AddStr := '';
  for i := 0 to Count - 1 do begin
    AddStr := AddStr + Get(i);
    if Char(Objects[i]) = #13 then begin
      AddStr := AddStr + #13;
    end;
  end;
  Result := StrNew(PChar(AddStr));
end;

procedure TDMemoStringList.SaveToFile(const FileName: string);
var
  TempString: TStringList;
  i: Integer;
  AddStr: string;
begin
  TempString := TStringList.Create;
  try
    AddStr := '';
    for i := 0 to Count - 1 do begin
      AddStr := AddStr + Get(i);
      if Char(Objects[i]) = #13 then begin
        TempString.Add(AddStr);
        AddStr := '';
      end;
    end;
    if AddStr <> '' then
      TempString.Add(AddStr);

    TempString.SaveToFile(FileName);
  finally
    TempString.Free;
  end;
end;

procedure TDMemoStringList.LoadFromFile(const FileName: string);
var
  TempString: TStringList;
  i: Integer;
begin
  Clear;
  TempString := TStringList.Create;
  try
    if FileExists(Filename) then begin
      TempString.LoadFromFile(FileName);
      for i := 0 to TempString.Count - 1 do begin
        Add(TempString[i]);
      end;
    end;
  finally
    TempString.Free;
  end;
end;

procedure TDMemoStringList.Put(Index: Integer; const Value: string);
var
  AddStr: string;
begin
  if Value <> '' then begin
    AddStr := AnsiReplaceText(Value, #13, '');
    AddStr := AnsiReplaceText(AddStr, #10, '');
  end
  else
    AddStr := #9;
  inherited Put(Index, AddStr);
end;

function TDMemoStringList.SelfGet(Index: Integer): string;
begin
  Result := inherited Get(Index);
end;





constructor TDModalWindow.Create(AOwner: TComponent);
begin
  inherited;
  MsgList := TStringList.Create;
  FillChar(DlgInfo, SizeOf(DlgInfo), #0);
end;

destructor TDModalWindow.Destroy;
begin
  MsgList.Free;
  inherited;
end;

function TDModalWindow.ModalClose: integer;
var
  i: integer;
begin
  Result := 0;
  for I := 0 to DControls.Count - 1 do begin
    if MouseCaptureControl = DControls[i] then MouseCaptureControl := nil;
    if FocusedControl = DControls[i] then FocusedControl := nil;
    if KeyControl = DControls[i] then KeyControl := nil;
    if ModalDWindow = DControls[i] then ModalDWindow := nil;
    if TopDWindow = DControls[i] then TopDWindow := nil;
    if MouseEntryControl = DControls[i] then MouseEntryControl := nil;
    if KeyDownControl = DControls[i] then KeyDownControl := nil;

  end;
  DControls.Clear;
  if MouseCaptureControl = Self then MouseCaptureControl := nil;
  if FocusedControl = Self then FocusedControl := nil;
  if KeyControl = Self then KeyControl := nil;
  if ModalDWindow = Self then ModalDWindow := nil;
  if TopDWindow = Self then TopDWindow := nil;
  if MouseEntryControl = Self then MouseEntryControl := nil;
  if KeyDownControl = Self then KeyDownControl := nil;
  

  for I := 0 to ModalDWindowList.Count - 1 do begin
    if ModalDWindowList[i] = Self then begin
      ModalDWindowList.Delete(i);
      break;
    end;
  end;
end;

function TDModalWindow.ModalShow: integer;
begin
  Result := ModalDWindowList.Add(Pointer(Self));
  Visible := True;
  SetDFocus(Self);
end;

{ TDCustomEdit }

constructor TDCustomEdit.Create(AOwner: TComponent);
begin
  inherited;
  FEditClass := deNone;
  FPasswordChar := #0;
end;

procedure TDCustomEdit.Enter;
begin
  inherited;
  if (FPasswordChar <> #0) or (FEditClass = deInteger) or (FEditClass = deMonoCase) then begin
    if ImmIsIME(GetKeyboardLayout(0)) then begin
      FrmShowIME := True;
      ImmSimulateHotKey(FrmMainWinHandle, IME_CHotKey_IME_NonIME_Toggle);
    end;
    FrmShowIME := False;
  end else begin
    FrmShowIME := True;
    if HklKeyboardLayout <> 0 then
      ActivateKeyboardLayout(HklKeyboardLayout, KLF_ACTIVATE);
    FrmIMEX := Left + 20;
    FrmIMEY := Top;
  end;
end;

procedure TDCustomEdit.IsVisible(flag: Boolean);
begin
  inherited;
  if (not flag) and (KeyControl = Self) then begin
    KeyControl.Leave;
    KeyControl := nil;
  end;
end;

procedure TDCustomEdit.Leave;
begin
  inherited;
  if not ((FPasswordChar <> #0) or (FEditClass = deInteger) or (FEditClass = deMonoCase)) then begin
    HklKeyboardLayout := GetKeyboardLayout(0);
  end;
  if ImmIsIME(GetKeyboardLayout(0)) then begin
    FrmShowIME := True;
    ImmSimulateHotKey(FrmMainWinHandle, IME_CHotKey_IME_NonIME_Toggle);
  end;
  FrmShowIME := False;
end;


{--------------------- TDListButton --------------------------}

constructor TDListButton.Create (AOwner: TComponent);
begin
   inherited Create (AOwner);
   FColCount := 1;
   FRowCount := 1;
   FColWidth := 20;
   FRowHeight:= 15;
   FOnGridSelect := nil;
   FOnGridMouseMove := nil;
   FOnGridPaint := nil;
end;

function  TDListButton.GetColRow (x, y: integer; var acol, arow: integer): Boolean;
begin
   Result := FALSE;
   if InRange (x, y) then begin
      acol := (x-Left) div FColWidth;
      arow := (y-Top) div FRowHeight;
      Result := TRUE;
   end;
end;

function  TDListButton.MouseDown (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
var
   acol, arow: integer;
begin
   Result := FALSE;
   if mbLeft = Button then begin
      if GetColRow (X, Y, acol, arow) then begin
         SelectCell.X := acol;
         SelectCell.Y := arow;
         DownPos.X := X;
         DownPos.Y := Y;
         SetDCapture (self);
         Result := TRUE;
      end;
   end;
end;


function  TDListButton.MouseMove (Shift: TShiftState; X, Y: Integer): Boolean;
var
   acol, arow: integer;
begin
   Result := FALSE;
   if InRange (X, Y) then begin
      if GetColRow (X, Y, acol, arow) then begin
         if Assigned (FOnGridMouseMove) then
            FOnGridMouseMove(Self,{ X, Y, }acol, arow, Shift);
      end;
      Result := TRUE;
   end;
end;

function  TDListButton.MouseUp (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
var
   acol, arow: integer;
begin
   Result := FALSE;
   if mbLeft = Button then begin
      if GetColRow (X, Y, acol, arow) then begin
         if (SelectCell.X = acol) and (SelectCell.Y = arow) then begin
            Col := acol;
            Row := arow;
            if Assigned (FOnGridSelect) then
               FOnGridSelect (Self,{ X, Y, }acol, arow, Shift);
         end;
         Result := TRUE;
      end;
      ReleaseDCapture;
   end;
end;

function  TDListButton.Click (X, Y: integer): Boolean;
begin
   Result := FALSE;
end;

procedure TDListButton.DirectPaint (dsurface: TDXDrawCanvas);
var
   i, j: integer;
   rc: TRect;
begin
   if Assigned (FOnGridPaint) then  begin
      FOnDirectPaint (self, dsurface);
      if FRowCount > 0 then //20080629
      for i:=0 to FRowCount-1 do
         for j:=0 to FColCount-1 do begin
            rc := Rect (Left + 3 + j*FColWidth, Top + 3 + i*FRowHeight, Left+ 3 +j*(FColWidth+1)-1, Top + 3 +i*(FRowHeight+1)-1);
            if (SelectCell.Y = i) and (SelectCell.X = j) then
               FOnGridPaint (self, j, i, rc, [gdSelected], dsurface)
            else FOnGridPaint (self, j, i, rc, [], dsurface);
         end; 
   end;
end;



{--------------------- TDMoveButton --------------------------}


constructor TDMoveButton.Create (AOwner: TComponent);
begin
   inherited Create (AOwner);
   Downed := FALSE;
   Moveed := False;
   MouseDownbo := False;
   FOnClick := nil;
   FClickSound := csNone;
   if MoveOutIDX > InMaxIDX then MoveOutIDX := InMaxIDX;
   if MoveOutIDX < 0 then MoveOutIDX := 0;
   InmfIDX := 0;
end;

procedure TDMoveButton.OnAddIDXCreateX(intdex: Integer);
begin
  if intdex < 0 then intdex := 0;
  if intdex > InMaxIDX then  intdex := InMaxIDX;
  InmfIDX :=  InMaxIDX div (MoveMaxX - MoveMinX);
  Left := MoveMinX + Round(intdex / InmfIDX);
  if Left > MoveMaxX then Left := MoveMaxX;
  if Left < MoveMinX then Left := MoveMinX;
  MoveOutIDX := intdex;
end;

function  TDMoveButton.MouseMove (Shift: TShiftState; X, Y: Integer): Boolean;
var
 SCX,SCY:Integer;
begin
   Result := inherited MouseMove (Shift, X, Y);
   Moveed := Result;
   if (not Background) and (not Result) then begin
      Result := inherited MouseMove (Shift, X, Y);
      if MouseCaptureControl = self then
         if InRange (X, Y) then
          Downed := TRUE
         else
          Downed := FALSE;
   end;
   if Downed then begin 
     if MoveXbo then begin
       if (MoveMinX < 0) and (MoveMaxX < 1) then exit;
       if X > TpotX then begin //右移
         SCX := X - TpotX;
         Left := SpotX + SCX;
         if Left >= MoveMaxX then Left := MoveMaxX;
         MoveOutIDX := Round((Left - MoveMinX) * InmfIDX);
         if (MoveOutIDX >= InMaxIDX) or (Left = MoveMaxX) then MoveOutIDX := InMaxIDX;
       end else begin //左移
         SCX := TpotX - X;
         Left := SpotX - SCX;
         if Left <= MoveMinX then Left := MoveMinX;
         MoveOutIDX := Round((Left - MoveMinX) * InmfIDX);
         if (MoveOutIDX <= 0) or (Left = MoveMinX) then MoveOutIDX := 0;
       end;
     end;
     if MoveYbo then begin
       if  (MoveMinY < 0) and (MoveMaxY <= 1) then exit;
       if Y > TpotY then begin  //下移
         SCY := Y - TpotY;
         Top := SpotY + SCY;
         if Top >= MoveMaxY then Top := MoveMaxY;
       end else begin //上移
         SCY := TpotY - Y;
         Top := SpotY - SCY;
         if Top <= MoveMinY then Top := MoveMinY;
       end;

     end;
   end;
end;


function  TDMoveButton.MouseDown (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
begin
   Result := FALSE;
   if inherited MouseDown (Button, Shift, X, Y) then begin
      if (not Background) and (MouseCaptureControl=nil) then begin
        if  TranFrame=False then  //2017.6.16 修正UI编辑器开发者模式不执行鼠标事件
         Downed := TRUE;
         Moveed := True;
         if (not MouseDownbo) and (InMaxIDX > 0) then begin
          MouseDownbo := True;
          TpotX := X;
          TpotY := Y;
          SpotX := Left;
          SpotY := Top;
          InmfIDX :=  InMaxIDX div (MoveMaxX - MoveMinX);
         end;
         SetDCapture (self);
      end;
      Result := TRUE;
   end;
end;

function  TDMoveButton.MouseUp (Button: TMouseButton; Shift: TShiftState; X, Y: Integer): Boolean;
begin
   Result := FALSE;
   if inherited MouseUp (Button, Shift, X, Y) then begin
      ReleaseDCapture;
      if not Background then begin
         if InRange (X, Y) then begin
            if Assigned (FOnClickSound) then FOnClickSound(self, FClickSound);
            if Assigned (FOnClick) then FOnClick(self, X, Y);
         end;
      end;
      Downed := FALSE;
      Result := TRUE;
      MouseDownbo := FALSE;
      exit;
   end else begin
      ReleaseDCapture;
      Downed := FALSE;
      MouseDownbo := FALSE;
   end;
end;


{ TDScrollBar }

procedure TDScrollBar.BarImageIndexChange(Sender: TObject);
var
  D: TDirectDrawSurface;
  nIndex: Integer;
begin
  nIndex := -1;
  if FBarImageIndex.Up >= 0 then
    nIndex := FBarImageIndex.Up
  else
    if FBarImageIndex.Hot >= 0 then
    nIndex := FBarImageIndex.Hot
  else
    if FBarImageIndex.Down >= 0 then
    nIndex := FBarImageIndex.Down;

  if (WLib <> nil) and (nIndex >= 0) then begin
    D := WLib.Images[nIndex];
    if D <> nil then
      FBarImageSize := D.Height;
  end;
end;

constructor TDScrollBar.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Width := 10;
  Height := 46;
  FPrevImageIndex := TDImageIndex.Create;
  FNextImageIndex := TDImageIndex.Create;
  FBarImageIndex := TDImageIndex.Create;

  FPrevImageIndex.OnChange := PrevImageIndexChange;
  FNextImageIndex.OnChange := NextImageIndexChange;
  FBarImageIndex.OnChange := BarImageIndexChange;

  FPrevMouseDown := False;
  FNextMouseDown := False;
  FBarMouseDown := False;

  FPrevMouseMove := False;
  FNextMouseMove := False;
  FBarMouseMove := False;

  FMaxValue := 100;
  FPosition := 0;
  FRemoveSize := 50;
  FItemHeight := 12;
  FItemIndex := -1;

  FBarTop := 0;
end;

destructor TDScrollBar.Destroy;
begin
  FPrevImageIndex.Free;
  FNextImageIndex.Free;
  FBarImageIndex.Free;
  inherited;
end;

procedure TDScrollBar.DirectPaint(dsurface: TDXDrawCanvas);
var
  d: TDXTexture;
  Rc:TRect;
  nIndex: Integer;
begin
  if Assigned (OnDirectPaint) then
    OnDirectPaint (self, dsurface)
  else begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        Rc := d.ClientRect;
        Rc.Bottom := Height;
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top), Rc, d, True);
        Rc := d.ClientRect;
        Rc.Top := d.Height-Height;
        Rc.Bottom := d.Height;
        dsurface.Draw (SurfaceX(Left), SurfaceY(Top)+1, Rc, d, True);
      end;
    end;
    nIndex := -1;
    if FPrevMouseDown and (FPrevImageIndex.Down >= 0) then nIndex := FPrevImageIndex.Down
    else if FPrevMouseMove and (FPrevImageIndex.Hot >= 0) then nIndex := FPrevImageIndex.Hot
    else if (FPrevImageIndex.Up >= 0) then nIndex := FPrevImageIndex.Up;
    if (nIndex >= 0) then begin
      D := WLib.Images[nIndex];
      if D <> nil then begin
        DSurface.Draw(SurfaceX(Left)+1, SurfaceY(Top)+1, D.ClientRect, D, True);
      end;
    end;

    nIndex := -1;
    if FNextMouseDown and (FNextImageIndex.Down >= 0) then nIndex := FNextImageIndex.Down
    else if FNextMouseMove and (FNextImageIndex.Hot >= 0) then nIndex := FNextImageIndex.Hot
    else if (FNextImageIndex.Up >= 0) then nIndex := FNextImageIndex.Up;
    if nIndex >= 0 then begin
      D := WLib.Images[nIndex];
      if D <> nil then begin
        DSurface.Draw(SurfaceX(Left)+1, SurfaceY(Top + Height - D.Height), D.ClientRect, D, True);
      end;
    end;

    nIndex := -1;
    if FBarMouseDown and (FBarImageIndex.Down >= 0) then nIndex := FBarImageIndex.Down
    else if FBarMouseMove and (FBarImageIndex.Hot >= 0) then nIndex := FBarImageIndex.Hot
    else if (FBarImageIndex.Up >= 0) then nIndex := FBarImageIndex.Up;
    if nIndex >= 0 then begin
      D := WLib.Images[nIndex];
      if D <> nil then begin
        DSurface.Draw(SurfaceX(Left)+1, SurfaceY(Top + FBarTop), D.ClientRect, D, True);
      end;
    end;
  end;
end;

procedure TDScrollBar.DoResize(var NewRect: TRect);
begin
  inherited;

end;


procedure TDScrollBar.First;
var
  P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
begin
  if FPosition > 0 then begin
    P := 0;
    if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
    FPosition := P;
  end;

  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

function TDScrollBar.InBarRange(X, Y: Integer): Boolean;
var
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
begin
  Result := False;
  if (X >= Left) and (Y < Top+Height - FNextImageSize) and
    (Y > Top + FPrevImageSize) then begin
    if FPosition > 0 then begin
      nMaxValue := FMaxValue - FRemoveSize;
      nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
      if (nMaxValue > 0) and (nHeight > 0) then
        nBarTop := Round(FPosition * nHeight / nMaxValue)
      else
        nBarTop := FPrevImageSize;
      Result := (Y >= Top + FPrevImageSize + nBarTop) and (Y <= Top + FPrevImageSize + nBarTop + FBarImageSize);
    end else begin
      Result := (Y <= Top + FPrevImageSize + FBarImageSize);
    end;
  end;
end;

function TDScrollBar.InNextRange(X, Y: Integer): Boolean;
begin
  Result := (X >= Left) and (Y >= Top + (Height - FNextImageSize));
end;

function TDScrollBar.InPrevRange(X, Y: Integer): Boolean;
begin
  Result := (X >= Left) and (Y <= Top + FPrevImageSize);
end;

procedure TDScrollBar.Last;
var
  P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
begin
  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0) and (nHeight > 0) and (nMaxValue > nHeight) then begin
    if FPosition < nMaxValue then begin
      P := nMaxValue;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end else begin
    if FPosition > 0 then begin
      P := 0;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

function TDScrollBar.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
var
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
begin
  Result := False;
  if inherited MouseDown(Button, Shift, X, Y) then begin
    if (not Background) and (MouseCaptureControl=nil) then begin
      FPrevMouseMove := False;
      FNextMouseMove := False;
      FBarMouseMove := False;
      if (Button = mbLeft) then begin
        FPrevMouseDown := InPrevRange(X, Y);
        FNextMouseDown := InNextRange(X, Y);
        FBarMouseDown := InBarRange(X, Y);
        if (not FPrevMouseDown) and (not FNextMouseDown) and (not FBarMouseDown) then begin
          if InRange(x, y) then begin
            nMaxValue := FMaxValue - FRemoveSize;
            nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
            if ((nMaxValue > 0) and (MaxValue > Height) and (nHeight > 0)) or (Position > 0) then begin
              nBarTop := Max(Y - Top - FPrevImageSize - FBarImageSize div 2, 0);
              Position := Round(nBarTop * nMaxValue / nHeight);
            end else begin
              Position := 0;
            end;

            if (nMaxValue > 0) and (nHeight > 0) then
              FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
            else
              FBarTop := 0;

            if FPosition = nMaxValue then
              FBarTop := Height - FNextImageSize - FBarImageSize
            else
              if FPosition = 0 then
              FBarTop := FPrevImageSize
            else
              FBarTop := FBarTop + FPrevImageSize;
            SetDCapture (self);
            Result := True;
            Exit;
          end;
        end else begin
          if FPrevMouseDown then begin
            Previous;
          end else
          if FNextMouseDown then begin
              Next;
          end;
          SetDCapture (self);
          Result := True;
          Exit;
        end;

      end;
      FItemIndex := (Y - Top) div FItemHeight + FPosition div FItemHeight;
      if FItemIndex >= FMaxValue div FItemHeight then
        FItemIndex := -1;
    end;
    Result := True;
  end;
end;

function TDScrollBar.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
begin
  Result := inherited MouseMove (Shift, X, Y);
  if Result then begin
    if MouseCaptureControl = self then begin
      if ssLeft in Shift then begin
        FPrevMouseMove := InPrevRange(X, Y);
        FNextMouseMove := InNextRange(X, Y);
        FBarMouseMove := InBarRange(X, Y);
        if FBarMouseDown then begin
          FPrevMouseMove := False;
          FNextMouseMove := False;
          nMaxValue := FMaxValue - FRemoveSize;
          nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
          if ((nMaxValue > 0) and (MaxValue > Height) and (nHeight > 0)) or (Position > 0) then begin
            nBarTop := Max(Y - Top - FPrevImageSize - FBarImageSize div 2, 0);
            Position := Round(nBarTop * nMaxValue / nHeight);
          end else begin
            Position := 0;
          end;
          
          if (nMaxValue > 0) and (nHeight > 0) then
            FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
          else
            FBarTop := 0;

          if FPosition = nMaxValue then
            FBarTop := Height - FNextImageSize - FBarImageSize
          else
            if FPosition = 0 then
            FBarTop := FPrevImageSize
          else
            FBarTop := FBarTop + FPrevImageSize;

            //Exit;
        end else begin
          FItemIndex := (Y - Top) div FItemHeight + FPosition div FItemHeight;
          if FItemIndex >= FMaxValue div FItemHeight then
            FItemIndex := -1;
        end;
      end;
    end;
  end;
end;

function TDScrollBar.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := inherited MouseUp(Button, Shift, X, Y);
  if Result then ReleaseDCapture;
  FBarMouseDown := False;
  FPrevMouseDown := False;
  FNextMouseDown := False;
end;

procedure TDScrollBar.Next;
var
  P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
begin
  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0)  and (nHeight > 0) then begin
    if (FPosition < nMaxValue) then begin
      if FPosition + FItemHeight <= nMaxValue then begin
        P := FPosition + FItemHeight;
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end else begin
        P := nMaxValue;
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end;
    end;
  end else begin
    if FPosition > 0 then begin
      P := 0;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end;
  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

procedure TDScrollBar.NextImageIndexChange(Sender: TObject);
var
  D: TDirectDrawSurface;
  nIndex: Integer;
begin
  nIndex := -1;
  if FNextImageIndex.Up >= 0 then
    nIndex := FNextImageIndex.Up
  else
    if FNextImageIndex.Hot >= 0 then
    nIndex := FNextImageIndex.Hot
  else
    if FNextImageIndex.Down >= 0 then
    nIndex := FNextImageIndex.Down;

  if (WLib <> nil) and (nIndex >= 0) then begin
    D := WLib.Images[nIndex];
    if D <> nil then
      FNextImageSize := D.Height;
  end;
end;

procedure TDScrollBar.PrevImageIndexChange(Sender: TObject);
var
  D: TDirectDrawSurface;
  nIndex: Integer;
begin
  nIndex := -1;
  if FPrevImageIndex.Up >= 0 then
    nIndex := FPrevImageIndex.Up
  else
    if FPrevImageIndex.Hot >= 0 then
    nIndex := FPrevImageIndex.Hot
  else
    if FPrevImageIndex.Down >= 0 then
    nIndex := FPrevImageIndex.Down;

  if (WLib <> nil) and (nIndex >= 0) then begin
    D := WLib.Images[nIndex];
    if D <> nil then
      FPrevImageSize := D.Height;
  end;
end;

procedure TDScrollBar.Previous;
var
  P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
begin
  if FPosition > 0 then begin
    nMaxValue := FMaxValue - FRemoveSize;
    nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nHeight > 0) then begin
      if FPosition - FItemHeight >= 0 then begin
        P := FPosition - FItemHeight;
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end else begin
        P := 0;
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end;
    end else begin
      P := 0;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

procedure TDScrollBar.SetItemHeight(Value: Integer);
begin
  FItemHeight := Max(Value, Canvas.TextHeight('Pp'));
end;

procedure TDScrollBar.SetItemIndex(Value: Integer);
var
  nItemCount: Integer;
begin
  if FItemIndex <> Value then begin
    FItemIndex := Value;
    nItemCount := FMaxValue div FItemHeight;
    if FItemIndex >= nItemCount then FItemIndex := -1;
    if FItemIndex >= 0 then begin
      if FItemIndex * FItemHeight < FRemoveSize then
        Position := 0
      else
        Position := FItemIndex * FItemHeight - FRemoveSize;
    end;
  end;
end;

procedure TDScrollBar.SetMaxValue(const Value: Integer);
var
  P, nMaxValue, nHeight: Integer;
begin
  if FMaxValue <> Value then begin
    FMaxValue := Max(Value, 0);
    if FMaxValue - FRemoveSize >= 0 then begin
      if FPosition > FMaxValue - FRemoveSize then begin
        P := Max(FMaxValue - FRemoveSize, 0);
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end;
    end else begin
      P := 0;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end;

             
  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

procedure TDScrollBar.SetPosition(const Value: Integer);
var
  P, nMaxValue, nHeight: Integer;
begin
  if FPosition <> Value then begin
    P := Value;
    if P < 0 then P := 0;
    if P > FMaxValue - FRemoveSize then
      P := Max(FMaxValue - FRemoveSize, 0);
    if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
    FPosition := P;
  end;
  
  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

procedure TDScrollBar.SetRemoveSize(const Value: Integer);
var
  P, nMaxValue, nHeight: Integer;
begin
  if FRemoveSize <> Value then begin
    FRemoveSize := Value;
    if FMaxValue - FRemoveSize >= 0 then begin
      if FPosition > FMaxValue - FRemoveSize then begin
        P := Max(FMaxValue - FRemoveSize, 0);
        if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
        FPosition := P;
      end;
    end else begin
      P := 0;
      if Assigned(FOnScroll) then FOnScroll(Self, FPosition - P);
      FPosition := P;
    end;
  end;

  nMaxValue := FMaxValue - FRemoveSize;
  nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

  if (nMaxValue > 0) and (nHeight > 0) then
    FBarTop := Max(Round(FPosition * nHeight / nMaxValue), 0)
  else
    FBarTop := 0;

  if FPosition = nMaxValue then
    FBarTop := Height - FNextImageSize - FBarImageSize
  else
    if FPosition = 0 then
    FBarTop := FPrevImageSize
  else
    FBarTop := FBarTop + FPrevImageSize;
end;

procedure TDScrollBar.SetScrollSize(const Value: Integer);
begin
  if FScrollSize <> Value then begin
    FScrollSize := Value;
  end;
end;

{ TDListItem }

function TDListItem.AddItem(const S: string;
  AObject: TObject): pTViewItem;
begin
  AddObject(S, AObject);
  Result := @FItemList[Length(FItemList) - 1];
end;

function TDListItem.AddObject(const S: string; AObject: TObject): Integer;
var
  ViewItem: pTViewItem;
begin
  SetLength(FItemList, Length(FItemList) + 1);
  ViewItem := @FItemList[Length(FItemList) - 1];
  ViewItem.Down := False;
  ViewItem.Move := False;
  ViewItem.Caption := S;
  ViewItem.Data := nil;
  ViewItem.WLib := nil;
  ViewItem.Style := bsButton;
  ViewItem.Checked := False;
  ViewItem.Color := TDCaptionColor.Create;
  ViewItem.ImageIndex := TDImageIndex.Create;
  ViewItem.TimeTick := GetTickCount;
  Result := inherited AddObject(S, AObject);
end;

procedure TDListItem.Clear;
var
  I: Integer;
begin
  for I := 0 to Length(FItemList) - 1 do begin
    FItemList[I].Color.Free;
    FItemList[I].ImageIndex.Free;
  end;
  SetLength(FItemList, 0);
  FItemList := nil;
  inherited Clear;
end;

constructor TDListItem.Create;
begin
  inherited;
  FItemList := nil;
end;

procedure TDListItem.Delete(Index: Integer);
var
  I: Integer;
begin
  FItemList[Index].Color.Free;
  FItemList[Index].ImageIndex.Free;
  for I := 0 to Length(FItemList) - 2 do begin
    FItemList[I] := FItemList[I + 1];
  end;
  SetLength(FItemList, Length(FItemList) - 1);
  inherited Delete(Index);
end;

destructor TDListItem.Destroy;
var
  I: Integer;
begin
  for I := 0 to Length(FItemList) - 1 do begin
    FItemList[I].Color.Free;
    FItemList[I].ImageIndex.Free;
  end;
  SetLength(FItemList, 0);
  FItemList := nil;
  inherited;
end;

function TDListItem.GetItem(Index: Integer): pTViewItem;
begin
  Result := @FItemList[Index];
end;

procedure TDListItem.InsertObject(Index: Integer; const S: string;
  AObject: TObject);
var
  I: Integer;
  ViewItem: pTViewItem;
begin
  SetLength(FItemList, Length(FItemList) + 1);
  for I := Length(FItemList) - 1 downto Index do begin
    FItemList[I] := FItemList[I - 1];
  end;
  ViewItem := @FItemList[Index];
  ViewItem.Down := False;
  ViewItem.Move := False;
  ViewItem.Caption := S;
  ViewItem.Data := nil;
  ViewItem.WLib := nil;
  ViewItem.Style := bsButton;
  ViewItem.Checked := False;
  ViewItem.Color := TDCaptionColor.Create;
  ViewItem.ImageIndex := TDImageIndex.Create;
  ViewItem.TimeTick := GetTickCount;
  inherited InsertObject(Index, S, AObject);
end;

{ TDListView }

function TDListView.Add: TDListItem;
begin
  Result := TDListItem.Create;
  FLines.Add(Result);
end;

procedure TDListView.Clear;
var
  I: Integer;
begin
  for I := 0 to FLines.Count - 1 do
    TDListItem(FLines[I]).Free;
  FLines.Clear;
end;

function TDListView.Click(X, Y: integer): Boolean;
var
  I: Integer;
  nWidth: Integer;
  nLeft: Integer;
  nCol: Integer;
  nRow: Integer;
  ViewItem: pTViewItem;
  ListItem: TDListItem;
begin
  Result := False;
  if inherited Click(X, Y) then begin
    Result := True;
    nCol := 0;
    nLeft := 0;
    nWidth := X - Left;
    for I := 0 to Length(ColWidths) - 1 do begin
      nLeft := nLeft + ColWidths[I];
      if nLeft >= nWidth then begin
        nCol := I;
        break;
      end;
    end;
    nRow := (Y - Top) div FHScrollBar.ItemHeight + FHScrollBar.Position div FHScrollBar.ItemHeight;
    if (nRow >= 0) and (nRow < FLines.Count) then begin
      ListItem := Items[nRow];
      if (nCol >= 0) and (nCol < ListItem.Count) then begin
        ViewItem := ListItem.Items[nCol];
        case ViewItem.Style of
          bsRadio: begin
              for I := 0 to ListItem.Count - 1 do begin
                ListItem.Items[I].Checked := False;
              end;
              ViewItem.Checked := True;
            end;
          bsCheckBox: begin
              ViewItem.Checked := not ViewItem.Checked;
            end;
        end;
        if Assigned(FOnListItemClick) then
          FOnListItemClick(Self, nRow, nCol, ListItem, ViewItem);
      end;
    end;
  end;
end;

constructor TDListView.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FLines := TList.Create;
  FOnScroll := nil;
  FColCount := 3;
  SetLength(ColWidths, FColCount);
  ColWidths[0] := Width div 3;
  ColWidths[1] := ColWidths[0];
  ColWidths[2] := ColWidths[0];
end;

destructor TDListView.Destroy;
var
  I: Integer;
begin
  for I := 0 to FLines.Count - 1 do
    TDListItem(FLines[I]).Free;
  FLines.Free;
  inherited Destroy;
end;

procedure TDListView.DirectPaint(dsurface: TDXDrawCanvas);
var
  I, II, nIndex, nCount, nLeft, nTop, n01: Integer;
  nFaceIndex: Integer;
  nMaxValue: Integer;
  D: TDXTexture;
  vtRect: TRect;
  vbRect: TRect;
  PaintRect: TRect;

  ListItem: TDListItem;
  ViewItem: pTViewItem;

  OldSize: Integer;
  OldFontName: TFontName;
  OldStyle: TFontStyles;

  Font: TDFont;
begin
  if Assigned (OnDirectPaint) then
    OnDirectPaint (self, dsurface)
  else begin
    if WLib <> nil then begin
      if FaceIndex >= 0 then begin
        D := WLib.Images[FaceIndex];
        if D <> nil then begin
          dsurface.StretchDraw(ClientRect,D.ClientRect, D, True);
        end;
      end;
    end;
    n01 := 0;
    nTop := Top;
    nIndex := HScrollBar.Position div HScrollBar.ItemHeight;  //索引
    nMaxValue := Height div HScrollBar.ItemHeight;   //显示多少个
    for I := nIndex to FLines.Count - 1 do begin
      ListItem := FLines[I];
      nCount := Min(ListItem.Count, FColCount);
      nLeft := Left;
      for II := 0 to nCount - 1 do begin
        ViewItem := ListItem.Items[II];
        if II > 0 then
          nLeft := nLeft + ColWidths[II - 1];

        if ViewItem.WLib <> nil then begin
          nFaceIndex := -1;
          if ViewItem.Style = bsButton then begin
            if ViewItem.Down then begin
              nFaceIndex := ViewItem.ImageIndex.Down;
              if (nFaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
                nFaceIndex := ViewItem.ImageIndex.Up;
            end else
              if ViewItem.Move then begin
              nFaceIndex := ViewItem.ImageIndex.Hot;
              if (nFaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
                nFaceIndex := ViewItem.ImageIndex.Up;
            end else
              nFaceIndex := ViewItem.ImageIndex.Up;
          end else begin
            if ViewItem.Move then begin
              if ViewItem.Checked then
                nFaceIndex := ViewItem.ImageIndex.Down
              else
                if ViewItem.ImageIndex.Hot >= 0 then
                nFaceIndex := ViewItem.ImageIndex.Hot
              else
                nFaceIndex := ViewItem.ImageIndex.Up;
            end else begin
              if ViewItem.Checked then
                nFaceIndex := ViewItem.ImageIndex.Down
              else
                nFaceIndex := ViewItem.ImageIndex.Up;
            end;
          end;

          if nFaceIndex >= 0 then begin
            D := ViewItem.WLib.Images[nFaceIndex];
            if D <> nil then begin
              DSurface.Draw(SurfaceX(nLeft) + (ColWidths[II] - D.Width) div 2, SurfaceY(nTop) + (HScrollBar.ItemHeight - D.Height) div 2, D.ClientRect, D, True);
            end;
          end;
        end;

        if ViewItem.Caption <> '' then begin
          if ViewItem.Down then begin
            Font := ViewItem.Color.Down;
          end else
            if ViewItem.Move then begin
            Font := ViewItem.Color.Hot;
          end else begin
            Font := ViewItem.Color.Up;
          end;
          if Font.Bold then
            g_DXCanvas.TextOutX(SurfaceX(nLeft), SurfaceY(nTop) + (FHScrollBar.ItemHeight - g_DXCanvas.TextHeight('0')) div 2, ViewItem.Caption, Font.Color, Font.BColor)
          else
           g_DXCanvas.TextOutX(SurfaceX(nLeft), SurfaceY(nTop) + (FHScrollBar.ItemHeight - g_DXCanvas.TextHeight('0')) div 2, ViewItem.Caption, Font.Color, Font.BColor);
        end;
      end;
      Inc(n01);
      Inc(nTop, FHScrollBar.ItemHeight);
      if n01 >= nMaxValue then break;
    end;
  end;
  if DControls.Count > 0 then //20080629
  for i:=0 to DControls.Count-1 do
    if TDControl(DControls[i]).Visible then
      TDControl(DControls[i]).DirectPaint (dsurface);
end;

procedure TDListView.DoScroll(Value: Integer);
var
  I: Integer;
  vRect: TRect;
  ARect: TRect;
  BRect: TRect;
  D: TDControl;
begin
  if Value <> 0 then begin
    vRect := Rect(0, 0, Width, Height);
    if DControls.Count > 0 then begin
      for i:=0 to DControls.Count-1 do begin
        D := DControls[I];
        if D is TDScrollBar then continue;
        D.Top := D.Top + Value;
        ARect := D.ClientRect;
        D.Visible := IntersectRect(BRect, vRect, ARect);
      end;
    end;
  end;
  if (Assigned(FOnScroll)) then FOnScroll(Self);
end;

procedure TDListView.FillItemMouse;
var
  I, II: Integer;
  ListItem: TDListItem;
begin
  for I := 0 to Count - 1 do begin
    ListItem := Items[I];
    for II := 0 to ListItem.Count - 1 do begin
      ListItem.Items[II].Down := False;
      ListItem.Items[II].Move := False;
    end;
  end;
end;

function TDListView.GetColWidth(Index: Integer): Integer;
begin
  Result := ColWidths[Index];
end;

function TDListView.GetCount: Integer;
begin
  Result := FLines.Count;
end;

function TDListView.GetViewItem(Index: Integer): TDListItem;
begin
  Result := FLines[Index];
end;

function TDListView.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
var
  I: Integer;
  nWidth: Integer;
  nLeft: Integer;
  nCol: Integer;
  nRow: Integer;
  ListItem: TDListItem;
begin
  Result := False;
  if inherited MouseDown(Button, Shift, X, Y) then begin
    if (not Background) and (MouseCaptureControl=nil) then begin
      Result := True;
      if (Button = mbLeft) then begin
      //FillItemMouse;
        nCol := 0;
        nLeft := 0;
        nWidth := X - Left;
        for I := 0 to Length(ColWidths) - 1 do begin
          nLeft := nLeft + ColWidths[I];
          if nLeft >= nWidth then begin
            nCol := I;
            break;
          end;
        end;
        nRow := (Y - Top) div FHScrollBar.ItemHeight + FHScrollBar.Position div FHScrollBar.ItemHeight;
        if (nRow >= 0) and (nRow < FLines.Count) then begin
          ListItem := Items[nRow];
          if (nCol >= 0) and (nCol < ListItem.Count) then begin
            ListItem.Items[nCol].Down := True;
            ListItem.Items[nCol].Move := False;
          end;
        end;
        SetDCapture (self);
      end;
    end;
    Result := True;
  end;
end;

function TDListView.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  I: Integer;
  nWidth: Integer;
  nLeft: Integer;
  nCol: Integer;
  nRow: Integer;
  ListItem: TDListItem;
begin
  Result := inherited MouseMove (Shift, X, Y);
  if (not Background) and (not Result) then begin
    Result := inherited MouseMove (Shift, X, Y);
  end else if InRange(x, y) then begin
    FillItemMouse;
    nCol := -1;
    nLeft := 0;
    nWidth := Min(X - Left, Width);
                               
    for I := 0 to Length(ColWidths) - 1 do begin
      nLeft := nLeft + ColWidths[I];
      if nLeft >= nWidth then begin
        nCol := I;
        break;
      end;
    end;
    nRow := (Y - Top) div FHScrollBar.ItemHeight + FHScrollBar.Position div FHScrollBar.ItemHeight;
    if (nRow >= 0) and (nRow < FLines.Count) then begin
      ListItem := Items[nRow];
      if (nCol >= 0) and (nCol < ListItem.Count) then begin
        ListItem.Items[nCol].Move := True;
      end;
    end;
  end;
end;

function TDListView.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
var
  I: Integer;
  nWidth: Integer;
  nLeft: Integer;
  nCol: Integer;
  nRow: Integer;
  ListItem: TDListItem;
begin
  Result := False;
  if inherited MouseUp(Button, Shift, X, Y) then begin
    ReleaseDCapture;
    Result := True;
    FillItemMouse;
    nCol := 0;
    nLeft := 0;
    nWidth := X - Left;
    for I := 0 to Length(ColWidths) - 1 do begin
      nLeft := nLeft + ColWidths[I];
      if nLeft >= nWidth then begin
        nCol := I;
        break;
      end;
    end;
    nRow := (Y - Top) div FHScrollBar.ItemHeight + FHScrollBar.Position div FHScrollBar.ItemHeight;
    if (nRow >= 0) and (nRow < FLines.Count) then begin
      ListItem := Items[nRow];
      if (nCol >= 0) and (nCol < ListItem.Count) then begin
        ListItem.Items[nCol].Down := False;
        ListItem.Items[nCol].Move := False;
      end;
    end;
  end else begin
    ReleaseDCapture;
  end;
end;

procedure TDListView.SetColCount(Value: Integer);
var
  I: Integer;
begin
  if FColCount <> Value then begin
    FColCount := Value;
    SetLength(ColWidths, FColCount);
    for I := 0 to FColCount - 1 do
      ColWidths[I] := Width div FColCount;
  end;
end;

procedure TDListView.SetColWidth(Index, Value: Integer);
begin
  if ColWidths[Index] <> Value then begin
    ColWidths[Index] := Value;
  end;
end;

procedure TDListView.SetHScrollBar(Value: TDScrollBar);
begin
  FHScrollBar := Value;
end;

 
{ TDChatMemo }

procedure TDChatMemo.Add(const S: string; FC, BC: TColor);
var
  TextWidth: Integer;

  I, Len, ALine: integer;
  sText, DLine, Temp: string;

  ViewItem: pTViewItem;
begin
  if ShowScroll then
    TextWidth := Width - ScrollSize - g_DXCanvas.TextWidth('0')
  else TextWidth := Width - g_DXCanvas.TextWidth('0');
  sText := S;
  if g_DXCanvas.TextWidth(sText) > TextWidth then begin
    Len := Length(sText);
    Temp := '';
    I := 1;
    while True do begin
      if I > Len then break;
      if Byte(sText[I]) >= 128 then begin
        Temp := Temp + sText[I];
        Inc(I);
        if I <= Len then Temp := Temp + sText[I]
        else break;
      end else
        Temp := Temp + sText[I];

      ALine := g_DXCanvas.TextWidth(Temp);
      if ALine > TextWidth then begin

        ViewItem := TDChatMemoLines(FLines).AddItem(Temp, nil);
        ViewItem.Transparent := False;
        ViewItem.Caption := Temp;
        ViewItem.Color.Up.Color := FC;
        ViewItem.Color.Up.BColor := BC;
        ViewItem.Color.Up.Bold := False;
        ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
        ViewItem.Color.Down.Assign(ViewItem.Color.Up);
        ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);
        TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1] := Max(TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1], ALine);
        sText := Copy(sText, I + 1, Len - i);
        Temp := '';

        if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
        if (Assigned(FOnChange)) then FOnChange(Self);
        break;
      end;
      Inc(I);
    end;

    if Temp <> '' then begin
      ViewItem := TDChatMemoLines(FLines).AddItem(Temp, nil);
      ViewItem.Transparent := False;
      ViewItem.Caption := Temp;
      ViewItem.Color.Up.Color := FC;
      ViewItem.Color.Up.BColor := BC;
      ViewItem.Color.Up.Bold := False;
      ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
      ViewItem.Color.Down.Assign(ViewItem.Color.Up);
      ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

      TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1] := Max(TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1], g_DXCanvas.TextWidth(Temp));

      sText := '';

      if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
      if (Assigned(FOnChange)) then FOnChange(Self);
    end;

    if sText <> '' then
      Add(' ' + sText, FC, BC);
  end else begin
    ViewItem := TDChatMemoLines(FLines).AddItem(sText, nil);
    ViewItem.Transparent := False;
    ViewItem.Caption := sText;
    ViewItem.Color.Up.Color := FC;
    ViewItem.Color.Up.BColor := BC;
    ViewItem.Color.Up.Bold := False;
    ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
    ViewItem.Color.Down.Assign(ViewItem.Color.Up);
    ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

    TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1] := Max(TDChatMemoLines(FLines).ItemHeights[FLines.Count - 1], g_DXCanvas.TextWidth(sText));

    if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
    if (Assigned(FOnChange)) then FOnChange(Self);
  end;
end;

procedure TDChatMemo.AddTop(const S: string; FC, BC: TColor; TimeOut: Integer);
var
  TextWidth: Integer;

  I, Len, ALine: integer;
  sText, DLine, Temp: string;

  ViewItem: pTViewItem;
begin
  if ShowScroll then
    TextWidth := Width - ScrollSize - g_DXCanvas.TextWidth('0')
  else TextWidth := Width - g_DXCanvas.TextWidth('0');

  sText := S;

  if g_DXCanvas.TextWidth(sText) > TextWidth then begin
    Len := Length(sText);
    Temp := '';
    I := 1;
    while True do begin
      if I > Len then break;
      if Byte(sText[I]) >= 128 then begin
        Temp := Temp + sText[I];
        Inc(I);
        if I <= Len then Temp := Temp + sText[I]
        else break;
      end else
        Temp := Temp + sText[I];

      ALine := g_DXCanvas.TextWidth(Temp);
      if ALine > TextWidth then begin
        ViewItem := TDChatMemoLines(FTopLines).AddItem(Temp, nil);
        ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
        ViewItem.Transparent := False;
        ViewItem.Caption := Temp;
        ViewItem.Color.Up.Color := FC;
        ViewItem.Color.Up.BColor := BC;
        ViewItem.Color.Up.Bold := False;
        ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
        ViewItem.Color.Down.Assign(ViewItem.Color.Up);
        ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

        sText := Copy(sText, I + 1, Len - i);
        Temp := '';

        if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
        if (Assigned(FOnChange)) then FOnChange(Self);
        break;
      end;
      Inc(I);
    end;

    if Temp <> '' then begin
      ViewItem := TDChatMemoLines(FTopLines).AddItem(Temp, nil);
      ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
      ViewItem.Transparent := False;
      ViewItem.Caption := Temp;
      ViewItem.Color.Up.Color := FC;
      ViewItem.Color.Up.BColor := BC;
      ViewItem.Color.Up.Bold := False;
      ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
      ViewItem.Color.Down.Assign(ViewItem.Color.Up);
      ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);
      sText := '';
      if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
      if (Assigned(FOnChange)) then FOnChange(Self);
    end;

    if sText <> '' then
      AddTop(' ' + sText, FC, BC, TimeOut);
  end else begin
    ViewItem := TDChatMemoLines(FTopLines).AddItem(sText, nil);
    ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
    ViewItem.Transparent := False;
    ViewItem.Caption := sText;
    ViewItem.Color.Up.Color := FC;
    ViewItem.Color.Up.BColor := BC;
    ViewItem.Color.Up.Bold := False;
    ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
    ViewItem.Color.Down.Assign(ViewItem.Color.Up);
    ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

    if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
    if (Assigned(FOnChange)) then FOnChange(Self);
  end;
end;

procedure TDChatMemo.BarImageIndexChange(Sender: TObject);
var
  d: TDirectDrawSurface;
  nIndex: Integer;
begin
  if FBarImageIndex.Up >= 0 then
    nIndex := FBarImageIndex.Up
  else
    if FBarImageIndex.Hot >= 0 then
    nIndex := FBarImageIndex.Hot
  else
    if FBarImageIndex.Down >= 0 then
    nIndex := FBarImageIndex.Down;

  if (WLib <> nil) and (nIndex >= 0) then begin
    d := WLib.Images[nIndex];
    if d <> nil then
      FBarImageSize := d.Height;
  end;
end;

procedure TDChatMemo.Clear;
begin
  FLines.Clear;
  FTopLines.Clear;
  Position := 0;
end;

constructor TDChatMemo.Create(AOwner: TComponent);
begin
  inherited Create (AOwner);
  Downed := False;
  FLines := TDChatMemoLines.Create;
  FTopLines := TDChatMemoLines.Create;
  FAutoScroll := False;
  FShowScroll := True;
  FScrollSize := 16;
  FItemHeight := 12;
  FItemIndex := -1;
  FBarTop := 0;
  FOffSetX := 0;
  FOffSetY := 0;
  FPosition := 0;
  FVisibleItemCount := 1;
  FExpandSize := 0;
  FDrawLineCount := 0;
  FScrollImageIndex := TDImageIndex.Create;
  FPrevImageIndex := TDImageIndex.Create;
  FNextImageIndex := TDImageIndex.Create;
  FBarImageIndex := TDImageIndex.Create;
  
  FScrollMouseDown := False;
  FPrevMouseDown := False;
  FNextMouseDown := False;
  FBarMouseDown := False;
  FPrevMouseMove := False;
  FNextMouseMove := False;
  FBarMouseMove := False;
  
  FScrollImageIndex.OnChange := ScrollImageIndexChange;
  FPrevImageIndex.OnChange := PrevImageIndexChange;
  FNextImageIndex.OnChange := NextImageIndexChange;
  FBarImageIndex.OnChange := BarImageIndexChange;
  FDrawLineCount := 0;
end;

procedure TDChatMemo.Delete(Index: Integer);
begin
  FLines.Delete(Index);
  if FAutoScroll then Previous;
end;

procedure TDChatMemo.DeleteTop(Index: Integer);
begin
  FTopLines.Delete(Index);
  if FAutoScroll then Previous;
end;

destructor TDChatMemo.Destroy;
begin
  FLines.Free;
  FTopLines.Free;
  FScrollImageIndex.Free;
  FPrevImageIndex.Free;
  FNextImageIndex.Free;
  FBarImageIndex.Free;
  inherited Destroy;
end;

procedure TDChatMemo.DirectPaint(dsurface: TDXDrawCanvas);
var
  I, II, III, nIndex, nCount, nLeft, nTop, n01: Integer;
  FaceIndex: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
  TextureRect: TDXTexture;
  Texture: TDXTexture;
  DC,vtRect: TRect;
  vbRect: TRect;
  PaintRect: TRect;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
  nLen: Integer;
  Font: TDFont;
begin
  //dsurface.FastFillRect(ClientRect, clRed);
  if Assigned (OnDirectPaint) then
    OnDirectPaint (self, dsurface)
  else begin
    n01 := 0;
    nTop := OffSetY;
    nLeft := OffSetX;

    nMaxValue := Min(VisibleHeight div ItemHeight, FDrawLineCount);

    for I := 0 to FTopLines.Count - 1 do begin
      ViewItem := TDChatMemoLines(FTopLines).Items[I];
      if WLib <> nil then begin
        FaceIndex := -1;
        if ViewItem.Style = bsButton then begin
          if ViewItem.Down then begin
            FaceIndex := ViewItem.ImageIndex.Down;
            if (FaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
              FaceIndex := ViewItem.ImageIndex.Up;
          end else
            if ViewItem.Move then begin
            FaceIndex := ViewItem.ImageIndex.Hot;
            if (FaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
              FaceIndex := ViewItem.ImageIndex.Up;
          end else
            FaceIndex := ViewItem.ImageIndex.Up;
        end else begin
          if ViewItem.Move then begin
            if ViewItem.Checked then
              FaceIndex := ViewItem.ImageIndex.Down
            else
              if ViewItem.ImageIndex.Hot >= 0 then
              FaceIndex := ViewItem.ImageIndex.Hot
            else
              FaceIndex := ViewItem.ImageIndex.Up;
          end else begin
            if ViewItem.Checked then
              FaceIndex := ViewItem.ImageIndex.Down
            else
              FaceIndex := ViewItem.ImageIndex.Up;
          end;
        end;

        if FaceIndex >= 0 then begin
          Texture := WLib.Images[FaceIndex];
          if Texture <> nil then begin
            dsurface.Draw(SurfaceX(Left)+ nLeft, SurfaceY(Top)+nTop + (ItemHeight - Texture.Height) div 2, Texture.ClientRect, Texture, False);
          end;
        end;
      end;

      if ViewItem.Caption <> '' then begin
        if ViewItem.Down then begin
          Font := ViewItem.Color.Down;
        end else
          if ViewItem.Move then begin
          Font := ViewItem.Color.Hot;
        end else begin
          Font := ViewItem.Color.Up;
        end;

        if ViewItem.Style = bsButton then begin
          if ViewItem.Down then begin
            Font := ViewItem.Color.Down;
          end else
            if ViewItem.Move then begin
            Font := ViewItem.Color.Hot;
          end else
            Font := ViewItem.Color.Up;
        end else begin
          if ViewItem.Move then begin
            if ViewItem.Checked then
              Font := ViewItem.Color.Down
            else
              if ViewItem.ImageIndex.Hot >= 0 then
              Font := ViewItem.Color.Hot
            else
              Font := ViewItem.Color.Up;
          end else begin
            if ViewItem.Checked then
              Font := ViewItem.Color.Down
            else
              Font := ViewItem.Color.Up;
          end;
        end;

        if ViewItem.Caption <> '' then begin
          if Font.Bold then begin
            g_DXCanvas.TextOutX(SurfaceX(Left), SurfaceY(Top), ViewItem.Caption, Font.Color, Font.BColor);
          end else begin
            PaintRect.Left := SurfaceX(Left) + nLeft;
            PaintRect.Right := PaintRect.Left + Width - ScrollSize;
            PaintRect.Top := SurfaceY(Top) + nTop + (ItemHeight - g_DXCanvas.TextHeight('0')) div 2;
            PaintRect.Bottom := PaintRect.Top + 12;
           g_DXCanvas.TextOutX(PaintRect.Left, PaintRect.Top, ViewItem.Caption, Font.Color, Font.BColor);
          end;
        end;
      end;
      Inc(n01);
      Inc(nTop, ItemHeight);
      if n01 >= nMaxValue then break;
    end;

    nMaxValue := Min(VisibleHeight div ItemHeight, FDrawLineCount);
    nMaxValue := nMaxValue - n01;

    n01 := 0;
    if nMaxValue > 0 then begin
      for I := FTopIndex to FLines.Count - 1 do begin
        ViewItem := TDChatMemoLines(FLines).Items[I];
        if WLib <> nil then begin
          FaceIndex := -1;
          if ViewItem.Style = bsButton then begin
            if ViewItem.Down then begin
              FaceIndex := ViewItem.ImageIndex.Down;
              if (FaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
                FaceIndex := ViewItem.ImageIndex.Up;
            end else
              if ViewItem.Move then begin
              FaceIndex := ViewItem.ImageIndex.Hot;
              if (FaceIndex < 0) and (ViewItem.ImageIndex.Up >= 0) then
                FaceIndex := ViewItem.ImageIndex.Up;
            end else
              FaceIndex := ViewItem.ImageIndex.Up;
          end else begin
            if ViewItem.Move then begin
              if ViewItem.Checked then
                FaceIndex := ViewItem.ImageIndex.Down
              else
                if ViewItem.ImageIndex.Hot >= 0 then
                FaceIndex := ViewItem.ImageIndex.Hot
              else
                FaceIndex := ViewItem.ImageIndex.Up;
            end else begin
              if ViewItem.Checked then
                FaceIndex := ViewItem.ImageIndex.Down
              else
                FaceIndex := ViewItem.ImageIndex.Up;
            end;
          end;

          if FaceIndex >= 0 then begin
            Texture := WLib.Images[FaceIndex];
            if Texture <> nil then begin
              dsurface.Draw(SurfaceX(Left)+ nLeft, SurfaceY(Top)+nTop + (ItemHeight - Texture.Height) div 2, Texture.ClientRect, Texture, False);
            end;
          end;
        end;

        if ViewItem.Caption <> '' then begin

          if ViewItem.Down then begin
            Font := ViewItem.Color.Down;
          end else
            if ViewItem.Move then begin
            Font := ViewItem.Color.Hot;
          end else begin
            Font := ViewItem.Color.Up;
          end;

          if ViewItem.Style = bsButton then begin
            if ViewItem.Down then begin
              Font := ViewItem.Color.Down;
            end else
              if ViewItem.Move then begin
              Font := ViewItem.Color.Hot;
            end else
              Font := ViewItem.Color.Up;
          end else begin
            if ViewItem.Move then begin
              if ViewItem.Checked then
                Font := ViewItem.Color.Down
              else
                if ViewItem.ImageIndex.Hot >= 0 then
                Font := ViewItem.Color.Hot
              else
                Font := ViewItem.Color.Up;
            end else begin
              if ViewItem.Checked then
                Font := ViewItem.Color.Down
              else
                Font := ViewItem.Color.Up;
            end;
          end;
          if ViewItem.Caption <> '' then begin
            if Font.Bold then begin
              g_DXCanvas.TextOutX(SurfaceX(Left), SurfaceY(Top), ViewItem.Caption,  Font.Color, Font.BColor);
            end else begin
              PaintRect.Left := SurfaceX(Left) + nLeft;
              PaintRect.Right := PaintRect.Left + g_DXCanvas.TextWidth(ViewItem.Caption);
              PaintRect.Top := SurfaceY(Top) + nTop + (ItemHeight - g_DXCanvas.TextHeight('0')) div 2;
              PaintRect.Bottom := PaintRect.Top + 12;
              g_DXCanvas.TextOutX(PaintRect.Left, PaintRect.Top, ViewItem.Caption,Font.Color, Font.BColor);
            end;
          end;
        end;

        Inc(n01);
        Inc(nTop, ItemHeight);
        if n01 >= nMaxValue then break;
      end;
    end;

    if FShowScroll then begin
       if WLib <> nil then begin
        nIndex := -1;
        if (FScrollImageIndex.Up >= 0) then nIndex := FScrollImageIndex.Up;
        if (nIndex >= 0) then begin
          Texture := WLib.Images[nIndex];
          if Texture <> nil then begin
             dsurface.Draw(SurfaceX(Left) +(Width - Texture.Width),
             SurfaceY(Top), Texture.ClientRect, Texture, True);
          end;
        end;
      end;

      if WLib <> nil then begin
        nIndex := -1;
        if FPrevMouseDown and (FPrevImageIndex.Down >= 0) then nIndex := FPrevImageIndex.Down
        else if FPrevMouseMove and (FPrevImageIndex.Hot >= 0) then nIndex := FPrevImageIndex.Hot
        else if (FPrevImageIndex.Up >= 0) then nIndex := FPrevImageIndex.Up;
        if (nIndex >= 0) then begin
          Texture := WLib.Images[nIndex];
          if Texture <> nil then begin
            dsurface.Draw(SurfaceX(Left) +(Width - FScrollSize) + ((FScrollSize - Texture.Width) div 2), SurfaceY(Top), Texture.ClientRect, Texture, True);
          end;
        end;
      end;

      if WLib <> nil then begin
        nIndex := -1;
        if FNextMouseDown and (FNextImageIndex.Down >= 0) then nIndex := FNextImageIndex.Down
        else if FNextMouseMove and (FNextImageIndex.Hot >= 0) then nIndex := FNextImageIndex.Hot
        else if (FNextImageIndex.Up >= 0) then nIndex := FNextImageIndex.Up;

        if nIndex >= 0 then begin
          Texture := WLib.Images[nIndex];
          if Texture <> nil then begin
            dsurface.Draw(SurfaceX(Left) +(Width - FScrollSize) + ((FScrollSize - Texture.Width) div 2), SurfaceY(Top)+ (Height - Texture.Height - 1), Texture.ClientRect, Texture, True);
          end;
        end;
      end;

      if WLib <> nil then begin
        nIndex := -1;
        if FBarMouseDown and (FBarImageIndex.Down >= 0) then nIndex := FBarImageIndex.Down
        else if FBarMouseMove and (FBarImageIndex.Hot >= 0) then nIndex := FBarImageIndex.Hot
        else if (FBarImageIndex.Up >= 0) then nIndex := FBarImageIndex.Up;

        if nIndex >= 0 then begin
          Texture := WLib.Images[nIndex];
          if Texture <> nil then begin
            dsurface.Draw(SurfaceX(Left) +(Width - FScrollSize) + (FScrollSize - Texture.Width) div 2, SurfaceY(Top)+ FPrevImageSize + FBarTop, Texture.ClientRect, Texture, True);
          end;
        end;
      end;
    end;
  end;
  if  TranFrame then begin
    dc.Left := SurfaceX(Left);
    dc.Top := SurfaceY(Top);
    dc.Right := SurfaceX(left + Width);
    dc.Bottom := SurfaceY(top + Height);
    g_DXCanvas.RoundRect(dc.Left, dc.Top, dc.Right, dc.Bottom, $FF00FFFF);
  end;
end;

procedure TDChatMemo.DoResize;
var
  nMaxScrollValue: Integer;
  nMaxValue: Integer;
begin
  if FShowScroll then begin
    nMaxValue := MaxValue;
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > VisibleHeight then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := Height - FPrevImageSize - FNextImageSize - FBarImageSize
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else begin
      FBarTop := 0;
      Position := 0;
    end;
  end;
end;

procedure TDChatMemo.DoScroll(Value: Integer);
begin
  FTopIndex := (Position - Value) div ItemHeight;
end;

procedure TDChatMemo.First;
var
  P: Integer;
  nMaxScrollValue: Integer;
  nMaxValue: Integer;
begin
  if FPosition > 0 then begin
    P := 0;
    DoScroll(FPosition - P);
    FPosition := P;
  end;

  if FShowScroll then begin
    nMaxValue := MaxValue;
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > VisibleHeight then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := nMaxScrollValue
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

function TDChatMemo.GetVisibleHeight: Integer;
begin
  Result := Height - OffSetY;
end;

function TDChatMemo.InBarRange(X, Y: Integer): Boolean;
var
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
begin
  Result := False;
  if FShowScroll then begin
    if (X >= Left + Width - FScrollSize) and (Y < Top +Height - FNextImageSize) and
      (Y > Top + FPrevImageSize) then begin
      if FPosition > 0 then begin
        nMaxValue := MaxValue;
        nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
        if (nMaxValue > 0) and (nHeight > 0) and (nMaxValue > VisibleHeight) then
          nBarTop := Round(FPosition * nHeight / (nMaxValue - VisibleHeight))
        else
          nBarTop := 0;
        Result := (Y >= Top + FPrevImageSize + nBarTop) and (Y <= Top + FPrevImageSize + nBarTop + FBarImageSize);
      end else begin
        Result := (Y <= Top + FPrevImageSize + FBarImageSize);
      end;
    end;
  end;
end;

function TDChatMemo.InNextRange(X, Y: Integer): Boolean;
begin
  Result := (X >= Left + Width - FScrollSize) and (Y >= Top + (Height - FNextImageSize));
end;

function TDChatMemo.InPrevRange(X, Y: Integer): Boolean;
begin
  Result := (X >= Left + Width - FScrollSize) and (Y <= Top + FPrevImageSize);
end;

procedure TDChatMemo.Insert(Index: Integer; const S: string; FC, BC: TColor);
var
  TextWidth: Integer;

  I, Len, ALine: integer;
  sText, DLine, Temp: string;

  ViewItem: pTViewItem;
begin
  if ShowScroll then
    TextWidth := Width - ScrollSize - g_DXCanvas.TextWidth('0')
  else TextWidth := Width - g_DXCanvas.TextWidth('0');

  sText := S;

  if g_DXCanvas.TextWidth(sText) > TextWidth then begin
    Len := Length(sText);
    Temp := '';
    I := 1;
    while True do begin
      if I > Len then break;
      if Byte(sText[I]) >= 128 then begin
        Temp := Temp + sText[I];
        Inc(I);
        if I <= Len then Temp := Temp + sText[I]
        else break;
      end else
        Temp := Temp + sText[I];

      ALine := g_DXCanvas.TextWidth(Temp);
      if ALine > TextWidth then begin
        TDChatMemoLines(FLines).Insert(Index, Temp);
        ViewItem := pTViewItem(FLines.Objects[Index]);
        ViewItem.Transparent := False;
        ViewItem.Caption := Temp;
        ViewItem.Color.Up.Color := FC;
        ViewItem.Color.Up.BColor := BC;
        ViewItem.Color.Up.Bold := False;
        ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
        ViewItem.Color.Down.Assign(ViewItem.Color.Up);
        ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

        sText := Copy(sText, I + 1, Len - i);
        Temp := '';

        if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
        if (Assigned(FOnChange)) then FOnChange(Self);
        break;
      end;
      Inc(I);
    end;

    if Temp <> '' then begin
      TDChatMemoLines(FLines).Insert(Index, Temp);
      ViewItem := pTViewItem(FLines.Objects[Index]);
      ViewItem.Transparent := False;
      ViewItem.Caption := Temp;
      ViewItem.Color.Up.Color := FC;
      ViewItem.Color.Up.BColor := BC;
      ViewItem.Color.Up.Bold := False;
      ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
      ViewItem.Color.Down.Assign(ViewItem.Color.Up);
      ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);
      sText := '';

      if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
      if (Assigned(FOnChange)) then FOnChange(Self);
    end;

    if sText <> '' then begin
      Inc(Index);
      Insert(Index, ' ' + sText, FC, BC);
    end;
  end else begin
    TDChatMemoLines(FLines).Insert(Index, Temp);
    ViewItem := pTViewItem(FLines.Objects[Index]);
    ViewItem.Transparent := False;
    ViewItem.Caption := sText;
    ViewItem.Color.Up.Color := FC;
    ViewItem.Color.Up.BColor := BC;
    ViewItem.Color.Up.Bold := False;
    ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
    ViewItem.Color.Down.Assign(ViewItem.Color.Up);
    ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

    if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
    if (Assigned(FOnChange)) then FOnChange(Self);
  end;
end;

procedure TDChatMemo.InsertTop(Index: Integer; const S: string; FC, BC: TColor;
  TimeOut: Integer);
var
  TextWidth: Integer;

  I, Len, ALine: integer;
  sText, DLine, Temp: string;

  ViewItem: pTViewItem;
begin
  if ShowScroll then
    TextWidth := Width - ScrollSize - g_DXCanvas.TextWidth('0')
  else TextWidth := Width - g_DXCanvas.TextWidth('0');

  sText := S;

  if g_DXCanvas.TextWidth(sText) > TextWidth then begin
    Len := Length(sText);
    Temp := '';
    I := 1;
    while True do begin
      if I > Len then break;
      if Byte(sText[I]) >= 128 then begin
        Temp := Temp + sText[I];
        Inc(I);
        if I <= Len then Temp := Temp + sText[I]
        else break;
      end else
        Temp := Temp + sText[I];

      ALine := g_DXCanvas.TextWidth(Temp);
      if ALine > TextWidth then begin
        TDChatMemoLines(FTopLines).Insert(Index, Temp);
        ViewItem := pTViewItem(FTopLines.Objects[Index]);
        ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
        ViewItem.Transparent := False;
        ViewItem.Caption := Temp;
        ViewItem.Color.Up.Color := FC;
        ViewItem.Color.Up.BColor := BC;
        ViewItem.Color.Up.Bold := False;
        ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
        ViewItem.Color.Down.Assign(ViewItem.Color.Up);
        ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

        sText := Copy(sText, I + 1, Len - i);
        Temp := '';

        if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
        if (Assigned(FOnChange)) then FOnChange(Self);
        break;
      end;
      Inc(I);
    end;

    if Temp <> '' then begin
      TDChatMemoLines(FTopLines).Insert(Index, Temp);
      ViewItem := pTViewItem(FTopLines.Objects[Index]);
      //ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
      ViewItem.Transparent := False;
      ViewItem.Caption := Temp;
      ViewItem.Color.Up.Color := FC;
      ViewItem.Color.Up.BColor := BC;
      ViewItem.Color.Up.Bold := False;
      ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
      ViewItem.Color.Down.Assign(ViewItem.Color.Up);
      ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);
      sText := '';
      if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
      if (Assigned(FOnChange)) then FOnChange(Self);
    end;

    if sText <> '' then begin
      Inc(Index);
      InsertTop(Index, ' ' + sText, FC, BC, TimeOut);
    end;
  end else begin
    TDChatMemoLines(FTopLines).Insert(Index, Temp);
    ViewItem := pTViewItem(FTopLines.Objects[Index]);
    //ViewItem.TimeTick := GetTickCount + TimeOut * 1000;
    ViewItem.Transparent := False;
    ViewItem.Caption := sText;
    ViewItem.Color.Up.Color := FC;
    ViewItem.Color.Up.BColor := BC;
    ViewItem.Color.Up.Bold := False;
    ViewItem.Color.Hot.Assign(ViewItem.Color.Up);
    ViewItem.Color.Down.Assign(ViewItem.Color.Up);
    ViewItem.Color.Disabled.Assign(ViewItem.Color.Up);

    if FAutoScroll and ((FTopLines.Count + FLines.Count) * ItemHeight > VisibleHeight) then Next;
    if (Assigned(FOnChange)) then FOnChange(Self);
  end;
end;

function TDChatMemo.KeyDown(var Key: Word; Shift: TShiftState): Boolean;
begin
  Result := False;
  if inherited KeyDown(Key, Shift) then begin
    Result := True;
    case Key of
      VK_UP: Previous;
      VK_DOWN: Next;
      VK_PRIOR: if Position >= Height then Position := Position - Height else Position := 0;
      VK_NEXT: if Position + Height < MaxValue then Position := Position + Height else Position := MaxValue;
    end;
  end;
end;

procedure TDChatMemo.Last;
var
  P: Integer;
  nMaxScrollValue: Integer;
  nMaxValue: Integer;
  nPosition: Integer;
begin
  nMaxValue := MaxValue;
  if (nMaxValue > 0) and (nMaxValue > VisibleHeight) then begin
    if FPosition + VisibleHeight < nMaxValue then begin
      P := nMaxValue - VisibleHeight;
      DoScroll(FPosition - P);
      FPosition := P;
    end;
  end else begin
    if FPosition > 0 then begin
      P := 0;
      DoScroll(FPosition - P);
      FPosition := P;
    end;
  end;

  if FShowScroll then begin
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > VisibleHeight then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := nMaxScrollValue
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

procedure TDChatMemo.LoadFromFile(const FileName: string);
begin
  FLines.LoadFromFile(FileName);
  FTopLines.Clear;
end;

function TDChatMemo.MaxValue: Integer;
begin
  Result := (FTopLines.Count + FLines.Count) * ItemHeight;
  if VisibleItemCount > 0 then begin
      Result := Result + (VisibleHeight - VisibleItemCount * ItemHeight);
  end;
  Result := Result + ExpandSize;
end;

function TDChatMemo.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
  function PointInRect(const Point: TPoint; const Rect: TRect): Boolean;
  begin
    Result := (Point.X >= Rect.Left) and (Point.X <= Rect.Right) and
      (Point.Y >= Rect.Top) and (Point.Y <= Rect.Bottom);
  end;
var
  I, P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
  vRect: TRect;
begin
  Result := FALSE;
  if (inherited MouseDown(Button, Shift, X, Y)) then begin
    Result := True;
    if (not Background) and (MouseCaptureControl=nil) then begin
      SetDCapture(Self);
      Downed := TRUE;
      if (Button = mbLeft) and FShowScroll then begin
        FScrollMouseDown := (X >= Left + Width - FScrollSize);
        if not (FPrevMouseDown or FNextMouseDown or FBarMouseDown) then begin
          FPrevMouseDown := InPrevRange(X, Y);
          FNextMouseDown := InNextRange(X, Y);
          FBarMouseDown := InBarRange(X, Y);
        end;

        if (not FPrevMouseDown) and (not FNextMouseDown) and (not FBarMouseDown) then begin
          vRect.Left := Left + Width - FScrollSize;
          vRect.Top := Top;
          vRect.Bottom := vRect.Top + Height;
          vRect.Right := vRect.Left + FScrollSize;
          if PointInRect(Point(X, Y), vRect) then begin
            nMaxValue := MaxValue;
            nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
            if ((nMaxValue > 0) and (nMaxValue > VisibleHeight) and (nHeight > 0)) or (Position > 0) then begin
              nBarTop := Max(Y - vRect.Top - FPrevImageSize - FBarImageSize div 2, 0);
              Position := Round(nBarTop * (nMaxValue - VisibleHeight) / nHeight);
            end else begin
              Position := 0;
            end;

            Exit;
          end;
        end else begin
          if FPrevMouseDown and InPrevRange(X, Y) then begin
            Previous;
          end else
            if FNextMouseDown and InNextRange(X, Y) then begin
            Next;
          end;
        end;
      end;
      FItemIndex := (Y - Top - OffSetY) div FItemHeight + FPosition div FItemHeight;
      if FItemIndex >= (MaxValue - VisibleItemCount * ItemHeight) div FItemHeight then
        FItemIndex := -1;
    end;
  end;
end;

function TDChatMemo.MouseMove(Shift: TShiftState; X, Y: Integer): Boolean;
var
  P: Integer;
  nHeight: Integer;
  nMaxValue: Integer;
  nBarTop: Integer;
begin
  Result := inherited MouseMove (Shift, X, Y);
  if (not Background) and (Result) then begin
    Result := inherited MouseMove (Shift, X, Y);
    //if InRange (X, Y) then begin
      if MouseCaptureControl = self then Downed := TRUE;
      if FShowScroll then begin
        if not (FPrevMouseDown or FNextMouseDown or FBarMouseDown or Downed or FScrollMouseDown) then begin
          FPrevMouseMove := InPrevRange(X, Y);
          FNextMouseMove := InNextRange(X, Y);
          FBarMouseMove := InBarRange(X, Y);
        end;
      end;
      if FBarMouseDown and FShowScroll then begin
        FPrevMouseMove := False;
        FNextMouseMove := False;

        FNextMouseDown := False;
        FPrevMouseDown := False;

        nMaxValue := MaxValue;
        nHeight := Height - FPrevImageSize - FNextImageSize - FBarImageSize;
        if ((nMaxValue > 0) and (nMaxValue > VisibleHeight) and (nHeight > 0)) or (Position > 0) then begin
          nBarTop := Max(Y - Top - FPrevImageSize - FBarImageSize div 2, 0);
          Position := Round(nBarTop * (nMaxValue - VisibleHeight) / nHeight);
        end else begin
          Position := 0;
        end;
      end else begin
        if FPrevMouseDown then begin
            Previous;
        end else if FNextMouseDown then begin
            Next;
        end;
        FItemIndex := (Y - Top - OffSetY) div FItemHeight + FPosition div FItemHeight;
        if FItemIndex >= (MaxValue - VisibleItemCount * ItemHeight) div FItemHeight then
          FItemIndex := -1;
      end;
  end else if not (FPrevMouseDown or FNextMouseDown or FBarMouseDown or Downed) then begin
        FPrevMouseMove := False;
        FNextMouseMove := False;
        FBarMouseMove := False;
  end;
end;

function TDChatMemo.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer): Boolean;
begin
  Result := FALSE;
  if inherited MouseUp (Button, Shift, X, Y) then begin
    ReleaseDCapture;
    Downed := FALSE;
    Result := TRUE;
    //Exit;
  end else begin
    ReleaseDCapture;
    Downed := FALSE;
  end;
  FBarMouseDown := False;
  FPrevMouseDown := False;
  FNextMouseDown := False;
  FPrevMouseMove := False;
  FNextMouseMove := False;
  FBarMouseMove := False;
  FScrollMouseDown := False;
end;

procedure TDChatMemo.Next;
var
  P: Integer;
  nMaxScrollValue: Integer;
  nMaxValue: Integer;
  nPosition: Integer;
begin
  nMaxValue := MaxValue;
  if (nMaxValue > 0) and (nMaxValue > VisibleHeight) then begin
    if (FPosition + VisibleHeight < nMaxValue) then begin
      if FPosition + VisibleHeight + FItemHeight <= nMaxValue then begin
        P := FPosition + FItemHeight;
        DoScroll(FPosition - P);
        FPosition := P;
      end else begin
        P := nMaxValue - VisibleHeight;
        DoScroll(FPosition - P);
        FPosition := P;
      end;
    end;
  end else begin
    if FPosition > 0 then begin
      P := 0;
      DoScroll(FPosition - P);
      FPosition := P;
    end;
  end;

  if FShowScroll then begin
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > (Height) then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := nMaxScrollValue
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

procedure TDChatMemo.NextImageIndexChange(Sender: TObject);
var
  d: TDirectDrawSurface;
  nIndex: Integer;
begin
  if FNextImageIndex.Up >= 0 then
    nIndex := FNextImageIndex.Up
  else
    if FNextImageIndex.Hot >= 0 then
    nIndex := FNextImageIndex.Hot
  else
    if FNextImageIndex.Down >= 0 then
    nIndex := FNextImageIndex.Down;

  if (WLib <> nil) and (nIndex >= 0) then begin
    d := WLib.Images[nIndex];
    if d <> nil then
      FNextImageSize := d.Height;
  end;
end;

procedure TDChatMemo.PrevImageIndexChange(Sender: TObject);
var
  d: TDirectDrawSurface;
  nIndex: Integer;
begin
  if (WLib <> nil) then begin
    if FPrevImageIndex.Up >= 0 then
      nIndex := FPrevImageIndex.Up
    else
      if FPrevImageIndex.Hot >= 0 then
      nIndex := FPrevImageIndex.Hot
    else
      if FPrevImageIndex.Down >= 0 then
      nIndex := FPrevImageIndex.Down;

    if (nIndex >= 0) then begin
      d := WLib.Images[nIndex];
      if d <> nil then
        FPrevImageSize := d.Height;
    end;
  end;
end;

procedure TDChatMemo.Previous;
var
  P: Integer;
  nMaxScrollValue: Integer;
  nMaxValue: Integer;
  nPosition: Integer;
begin
  nMaxValue := MaxValue;
  if FPosition > 0 then begin
    if (nMaxValue > 0) and (nMaxValue > VisibleHeight) then begin
      if FPosition - FItemHeight >= 0 then begin
        P := FPosition - FItemHeight;
        DoScroll(FPosition - P);
        FPosition := P;
      end else begin
        P := 0;
        DoScroll(FPosition - P);
        FPosition := P;
      end;
    end else begin
      P := 0;
      DoScroll(FPosition - P);
      FPosition := P;
    end;
  end;

  if FShowScroll then begin
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > VisibleHeight then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := nMaxScrollValue
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

procedure TDChatMemo.ScrollImageIndexChange(Sender: TObject);
var
  d: TDirectDrawSurface;
  nIndex: Integer;
begin
  if (WLib <> nil) then begin
    if FScrollImageIndex.Up >= 0 then
      nIndex := FScrollImageIndex.Up
    else
      if FScrollImageIndex.Hot >= 0 then
      nIndex := FScrollImageIndex.Hot
    else
      if FScrollImageIndex.Down >= 0 then
      nIndex := FScrollImageIndex.Down;

    if (nIndex >= 0) then begin
      d := WLib.Images[nIndex];
      if d <> nil then
        FScrollSize := d.Width;
    end;
  end;
end;

procedure TDChatMemo.SetExpandSize(Value: Integer);
var
  nMaxValue, nMaxScrollValue: Integer;
begin
  if FExpandSize <> Value then begin
    FExpandSize := Value;
    if FShowScroll then begin
      nMaxValue := MaxValue;
      nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

      if (nMaxValue > 0) and (nMaxScrollValue > 0) then
        FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
      else
        FBarTop := 0;

      if nMaxValue > (Height) then begin
        if FPosition + VisibleHeight >= nMaxValue then
          FBarTop := nMaxScrollValue
        else
          if FPosition = 0 then
          FBarTop := 0;
      end else FBarTop := 0;
    end;
  end;
end;

procedure TDChatMemo.SetItemHeight(Value: Integer);
begin
  FItemHeight := Max(Value, 1);
end;

procedure TDChatMemo.SetItemIndex(Value: Integer);
var
  nItemCount: Integer;
begin
  if FItemIndex <> Value then begin
    FItemIndex := Value;
    nItemCount := (MaxValue - VisibleItemCount * ItemHeight) div FItemHeight;
    if FItemIndex >= nItemCount then FItemIndex := -1;
    if FItemIndex >= 0 then begin
      Position := FItemIndex * FItemHeight;
    end;
  end;
end;

procedure TDChatMemo.SetLines(Value: TStrings);
begin
  FLines.Clear;
  FLines.AddStrings(Value);
end;

procedure TDChatMemo.SetPosition(Value: Integer); //设置滚动指针
var
  P, nMaxValue, nMaxScrollValue: Integer;
begin
  nMaxValue := MaxValue;
  if FPosition <> Value then begin
    P := Value;
    if P < 0 then P := 0;

    if VisibleHeight > nMaxValue then begin
      P := 0;
    end else begin
      if P + VisibleHeight > nMaxValue then
        P := nMaxValue - VisibleHeight;
    end;

    DoScroll(FPosition - P);
    FPosition := P;
  end;

  if FShowScroll then begin
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > VisibleHeight then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := Height - FPrevImageSize - FNextImageSize - FBarImageSize
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

procedure TDChatMemo.SetScrollSize(Value: Integer);
begin
  if FScrollSize <> Value then begin
    FScrollSize := Value;
  end;
end;

procedure TDChatMemo.SetTopLines(Value: TStrings);
begin
  FTopLines.Clear;
  FTopLines.AddStrings(Value);
end;
procedure TDChatMemo.SetVisibleItemCount(Value: Integer);
var
  nMaxValue, nMaxScrollValue: Integer;
begin
  if VisibleHeight div ItemHeight < Value then
    FVisibleItemCount := 0
  else
    FVisibleItemCount := Value;

  if FShowScroll then begin
    nMaxValue := MaxValue;
    nMaxScrollValue := Height - FPrevImageSize - FNextImageSize - FBarImageSize;

    if (nMaxValue > 0) and (nMaxScrollValue > 0) then
      FBarTop := Max(Round(FPosition * nMaxScrollValue / (nMaxValue - VisibleHeight)), 0)
    else
      FBarTop := 0;

    if nMaxValue > (Height) then begin
      if FPosition + VisibleHeight >= nMaxValue then
        FBarTop := nMaxScrollValue
      else
        if FPosition = 0 then
        FBarTop := 0;
    end else FBarTop := 0;
  end;
end;

{ TDChatMemoLines }

function TDChatMemoLines.AddItem(const S: string; AObject: TObject): pTViewItem;
begin
  AddObject(S, AObject);
  Result := @FItemList[Length(FItemList) - 1];
end;

function TDChatMemoLines.AddObject(const S: string; AObject: TObject): Integer;
var
  ViewItem: pTViewItem;
begin
  SetLength(FItemList, Length(FItemList) + 1);
  SetLength(FItemHeightList, Length(FItemHeightList) + 1);
  FItemHeightList[Length(FItemHeightList) - 1] := 0;
  ViewItem := @FItemList[Length(FItemList) - 1];
  ViewItem.Down := False;
  ViewItem.Move := False;
  ViewItem.Caption := S;
  ViewItem.Data := nil;
  ViewItem.Style := bsButton;
  ViewItem.Checked := False;
  ViewItem.Color := TDCaptionColor.Create;
  ViewItem.ImageIndex := TDImageIndex.Create;
  ViewItem.TimeTick := GetTickCount;
  Result := inherited AddObject(S, AObject);
end;

procedure TDChatMemoLines.Clear;
var
  I: Integer;
begin
  for I := 0 to Length(FItemList) - 1 do begin
    FItemList[I].Color.Free;
    FItemList[I].ImageIndex.Free;
  end;
  SetLength(FItemList, 0);
  SetLength(FItemHeightList, 0);
  FItemList := nil;
  FItemHeightList := nil;
  inherited Clear;
end;

constructor TDChatMemoLines.Create;
begin
  inherited;
  FItemList := nil;
  FItemHeightList := nil;
end;

procedure TDChatMemoLines.Delete(Index: Integer);
var
  I: Integer;
begin
  FItemList[Index].Color.Free;
  FItemList[Index].ImageIndex.Free;
  for I := Index to Length(FItemList) - 2 do begin
    FItemList[I] := FItemList[I + 1];
    FItemHeightList[I] := FItemHeightList[I + 1];
  end;
  SetLength(FItemList, Length(FItemList) - 1);
  SetLength(FItemHeightList, Length(FItemHeightList) - 1);
  inherited Delete(Index);
end;

destructor TDChatMemoLines.Destroy;
var
  I: Integer;
begin
  for I := 0 to Length(FItemList) - 1 do begin
    FItemList[I].Color.Free;
    FItemList[I].ImageIndex.Free;
  end;
  SetLength(FItemList, 0);
  SetLength(FItemHeightList, 0);
  FItemList := nil;
  FItemHeightList := nil;
  inherited;
end;

function TDChatMemoLines.GetItem(Index: Integer): pTViewItem;
begin
  Result := @FItemList[Index];
end;

function TDChatMemoLines.GetItemHeight(Index: Integer): Integer;
begin
  Result := FItemHeightList[Index];
end;

procedure TDChatMemoLines.InsertObject(Index: Integer; const S: string;
  AObject: TObject);
var
  I: Integer;
  ViewItem: pTViewItem;
begin
  SetLength(FItemList, Length(FItemList) + 1);
  SetLength(FItemHeightList, Length(FItemHeightList) + 1);
  for I := Length(FItemList) - 1 downto Index do begin
    FItemList[I] := FItemList[I - 1];
    FItemHeightList[I] := FItemHeightList[I - 1];
  end;
  FItemHeightList[Index] := 0;
  ViewItem := @FItemList[Index];
  ViewItem.Down := False;
  ViewItem.Move := False;
  ViewItem.Caption := S;
  ViewItem.Data := nil;
  ViewItem.Style := bsButton;
  ViewItem.Checked := False;
  ViewItem.Color := TDCaptionColor.Create;
  ViewItem.ImageIndex := TDImageIndex.Create;
  ViewItem.TimeTick := GetTickCount;
  inherited InsertObject(Index, S, AObject);
end;

procedure TDChatMemoLines.SetItemHeight(Index, Value: Integer);
begin
  FItemHeightList[Index] := Value;
end;


initialization
  begin
    GetMem(ChrBuff, 2048);
    ModalDWindowList := TList.Create;
  end;

finalization
  begin
    FreeMem(ChrBuff);
    ModalDWindowList.Free;
  end;

end.









